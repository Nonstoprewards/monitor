import pkg from '@solana/web3.js';
const { Connection, Keypair, LAMPORTS_PER_SOL, PublicKey, Transaction, SystemProgram, sendAndConfirmTransaction, TransactionInstruction, SYSVAR_RENT_PUBKEY, SendTransactionError, VersionedTransaction } = pkg;
import * as splToken from '@solana/spl-token';
import { createClient } from '@supabase/supabase-js';
import axios from 'axios';
import * as dotenv from 'dotenv';
import bs58 from 'bs58';
import fs from 'fs/promises';
import fetch from 'node-fetch';
import TelegramBot from 'node-telegram-bot-api';
dotenv.config();
console.log('QUICKNODE_URL:', process.env.QUICKNODE_URL);
console.log('SOLANA_PRIVATE_KEY:', process.env.SOLANA_PRIVATE_KEY ? '[REDACTED]' : 'undefined');
console.log('SUPABASE_URL:', process.env.SUPABASE_URL);
console.log('SUPABASE_SERVICE_KEY:', process.env.SUPABASE_SERVICE_KEY ? '[REDACTED]' : 'undefined');
const TELEGRAM_TOKEN = '7898822158:AAHgGMOHqq5fX-vlLQB7WuTLz7Qb2v-dfgg';
const telegramBot = new TelegramBot(TELEGRAM_TOKEN, { polling: true });
const TELEGRAM_CHANNEL = '@YourChannelName'; // Replace with the channel/group to monitor
const SOLANA_ADDRESS_REGEX = /[1-9A-HJ-NP-Za-km-z]{44}/g;
const RUGCHECK_API = 'https://api.rugcheck.xyz/v1/tokens';

// NEW: Helper function to create a timeout signal for fetch
function createTimeoutSignal(ms) {
  const controller = new AbortController();
  setTimeout(() => controller.abort(), ms);
  return controller.signal;
}

// NEW: Function to check liquidity lock status using RugCheck API
async function getLiquidityLockStatus(tokenAddress) {
  const url = `${RUGCHECK_API}/${tokenAddress}/report`;
  const maxRetries = 3;
  let retryCount = 0;
  while (retryCount < maxRetries) {
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: createTimeoutSignal(30000) // 30-second timeout
      });
      if (response.ok) {
        const report = await response.json();
        const lp = report?.markets?.[0]?.lp || {};
        const lockedPct = lp.lpLockedPct || 0;
        const lockedUsd = lp.lpLockedUSD || 0;
        console.log(`RugCheck for ${tokenAddress}: Locked Percentage: ${lockedPct}%, Locked Value: ${lockedUsd} USD`);
        return { lockedPct, lockedUsd, success: true };
      } else {
        console.error(`RugCheck error for ${tokenAddress}: Status ${response.status}, ${await response.text()}`);
        return { success: false };
      }
    } catch (error) {
      retryCount++;
      if (retryCount === maxRetries) {
        console.error(`RugCheck failed for ${tokenAddress} after ${maxRetries} attempts: ${error.message}`);
        return { success: false };
      }
      console.log(`RugCheck retry (${retryCount}/${maxRetries}) for ${tokenAddress}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, retryCount * 1000)); // Backoff
    }
  }
  return { success: false };
}

async function getTokenPrice(tokenAddress) {
  const maxRetries = 3;
  let attempt = 1;
  while (attempt <= maxRetries) {
    try {
      console.log(`Fetching single price for ${tokenAddress} from Jupiter (attempt ${attempt})`);
      const response = await axios.get(`https://api.jup.ag/price/v2`, {
        params: { ids: tokenAddress },
        timeout: 5000
      });
      const price = response.data.data?.[tokenAddress]?.price;
      if (!price) {
        throw new Error(`No price data returned for ${tokenAddress}: ${JSON.stringify(response.data.data)}`);
      }
      console.log(`Jupiter single price for ${tokenAddress}: $${price}`);
      return price;
    } catch (error) {
      console.error(`Error fetching single price for ${tokenAddress} from Jupiter (attempt ${attempt}):`, error.message);
      if (error.response) {
        if (error.response.status === 400) {
          throw new Error(`Invalid token address or no data available for ${tokenAddress}`);
        }
        if (error.response.status === 429 && attempt < maxRetries) {
          console.log(`Rate limit hit, retrying after 10 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 10000));
          attempt++;
          continue;
        }
      } else if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        console.error(`Request timed out`);
        if (attempt < maxRetries) {
          console.log(`Retrying after ${Math.pow(2, attempt) * 1000}ms...`);
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
          attempt++;
          continue;
        }
      }
      throw new Error(`Failed to fetch price for ${tokenAddress} after ${attempt} attempts: ${error.message}`);
    }
  }
}

async function getMultiTokenPrices(tokenAddresses) {
  const maxRetries = 3;
  let attempt = 1;
  if (tokenAddresses.length === 0) throw new Error('No token addresses provided for multi_price');
  while (attempt <= maxRetries) {
    try {
      console.log(`Fetching multi prices for ${tokenAddresses.length} tokens from Jupiter (attempt ${attempt})`);
      const response = await axios.get(`https://api.jup.ag/price/v2`, {
        params: { ids: tokenAddresses.join(',') },
        timeout: 5000
      });
      const prices = {};
      for (const address of tokenAddresses) {
        const data = response.data.data?.[address];
        if (!data || !data.price) {
          throw new Error(`No price data returned for ${address} in multi_price: ${JSON.stringify(response.data.data?.[address] || {})}`);
        }
        prices[address] = data.price;
        console.log(`Price for ${address}: $${data.price}`);
      }
      console.log(`Prices returned for ${Object.keys(prices).length} tokens`);
      return prices;
    } catch (error) {
      console.error(`Error fetching multi prices for ${tokenAddresses.length} tokens (attempt ${attempt}):`, error.message);
      if (error.response) {
        if (error.response.status === 400) {
          throw new Error(`Invalid token addresses or no data available`);
        }
        if (error.response.status === 429 && attempt < maxRetries) {
          console.log(`Rate limit hit, retrying after 10 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 10000));
          attempt++;
          continue;
        }
      } else if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        console.error(`Request timed out`);
        if (attempt < maxRetries) {
          console.log(`Retrying after ${Math.pow(2, attempt) * 1000}ms...`);
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
          attempt++;
          continue;
        }
      }
      throw new Error(`Failed to fetch multi prices after ${attempt} attempts: ${error.message}`);
    }
  }
}

async function getCirculatingSupply(tokenAddress) {
  const maxRetries = 3;
  let attempt = 1;
  while (attempt <= maxRetries) {
    try {
      console.log(`Fetching supply for ${tokenAddress} from Solana blockchain (attempt ${attempt})`);
      const mint = new PublicKey(tokenAddress);
      const { program: tokenProgram } = await getTokenProgramAndExtensions(mint, connection);
      if (!tokenProgram) {
        throw new Error(`Invalid or unsupported token program for ${tokenAddress}`);
      }
      const mintInfo = await splToken.getMint(connection, mint, 'confirmed', tokenProgram);
      const supply = Number(mintInfo.supply) / Math.pow(10, mintInfo.decimals);
      console.log(`Supply for ${tokenAddress}: ${supply} (decimals: ${mintInfo.decimals})`);
      return supply;
    } catch (error) {
      console.error(`Error fetching supply for ${tokenAddress} (attempt ${attempt}):`, error.message);
      if (attempt === maxRetries) {
        throw new Error(`Failed to fetch supply for ${tokenAddress} after ${maxRetries} attempts`);
      }
      attempt++;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

const connection = new Connection(process.env.QUICKNODE_URL, 'confirmed');
const wallet = Keypair.fromSecretKey(bs58.decode(process.env.SOLANA_PRIVATE_KEY));
const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_KEY);
const BUY_AMOUNT = 0.26 * LAMPORTS_PER_SOL;
const MIN_TRADE_BALANCE = 0.17 * LAMPORTS_PER_SOL;
const MIN_BALANCE = 0.17 * LAMPORTS_PER_SOL;
const ATA_RENT_LAMPORTS = 2039280;
const MIN_SELL_FEE_LAMPORTS = 100000;
const PROFIT_TARGET = 20;
const STOP_LOSS = -99;
const HOLD_DURATION = 1000000;
const PRICE_CHECK_INTERVAL = 6 * 1000;
const DEXSCREENER_API = 'https://api.dexscreener.com';
const JUPITER_API = 'https://quote-api.jup.ag/v6';
const CACHE_FILE = 'tokens_cache_bot2.json';
const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const TOKEN_2022_PROGRAM_ID = new PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');
const EXCLUDED_TOKEN_TTL = 7 * 24 * 60 * 60 * 1000;
const MIN_MARKET_CAP = 1000;
const MAX_MARKET_CAP = 20000;
const MAX_HISTORICAL_MARKET_CAP = 20000;
const PRIORITY_FEE_LAMPORTS = 900000;
const MARKET_CAP_SELL_THRESHOLD = 50000;
const HISTORICAL_CACHE_TTL = 12 * 60 * 60 * 1000; // 12 hours
let activeTrades = [];

async function saveActiveTrades() {
  try {
    console.log(`Saving ${activeTrades.length} active trades to Supabase...`);
    for (const trade of activeTrades) {
      const { error } = await supabase
        .from('trades_bot2')
        .update({
          token_account: trade.tokenAccount.toBase58(),
          buy_price_usd: trade.buyPrice,
          buy_timestamp: new Date(trade.buyTime).toISOString(),
          status: trade.partialSell ? 'partial_sold' : 'open',
        })
        .eq('id', trade.tradeId);
      if (error) console.error(`Error saving trade ${trade.tradeId}:`, error.message);
      else console.log(`Saved trade ${trade.tradeId}`);
    }
    console.log('Active trades saved');
  } catch (error) {
    console.error('Error saving active trades:', error.message);
  }
}

async function loadActiveTrades() {
  try {
    console.log('Loading active trades from Supabase...');
    const { data, error } = await supabase
      .from('trades_bot2')
      .select('id, token_address, buy_price_usd, buy_timestamp, token_account, status')
      .in('status', ['open', 'partial_sold'])
      .eq('wallet_address', wallet.publicKey.toBase58());
    if (error) {
      console.error('Error loading active trades:', error.message);
      return;
    }
    activeTrades = [];
    for (const trade of data) {
      try {
        const tokenAccount = new PublicKey(trade.token_account);
        activeTrades.push({
          tradeId: trade.id,
          tokenAddress: trade.token_address,
          buyPrice: trade.buy_price_usd,
          buyTime: new Date(trade.buy_timestamp).getTime(),
          tokenAccount,
          partialSell: trade.status === 'partial_sold',
        });
        console.log(`Loaded trade for ${trade.token_address}, tradeId: ${trade.id}, status: ${trade.status}`);
      } catch (error) {
        console.error(`Failed to load trade ${trade.id} for ${trade.token_address}: Invalid token_account ${trade.token_account}`, error.message);
        await supabase
          .from('trades_bot2')
          .update({
            status: 'failed',
            error_message: `Invalid token_account: ${error.message}`,
          })
          .eq('id', trade.id);
      }
    }
    console.log(`Loaded ${activeTrades.length} active trades:`, activeTrades.map(t => t.tokenAddress));
    activeTrades.forEach(trade => {
      console.log(`Resuming monitoring for ${trade.tokenAddress}, tradeId: ${trade.tradeId}, partialSell: ${trade.partialSell}`);
      monitorAndSell(trade).catch(error => console.error(`Error monitoring ${trade.tokenAddress}:`, error.message));
    });
  } catch (error) {
    console.error('Unexpected error loading active trades:', error.message);
  }
}
      async function pruneExcludedTokens() {
  try {
    console.log('Pruning old entries from excluded_tokens_bot2...');
    const { data, error } = await supabase
      .from('excluded_tokens_bot2')
      .delete()
      .lt('created_at', new Date(Date.now() - EXCLUDED_TOKEN_TTL).toISOString());
    if (error) {
      console.error('Error pruning excluded_tokens_bot2:', error.message);
      return;
    }
    console.log(`Pruned ${data ? data.length : 0} old excluded tokens`);

    const { data: allExclusions, error: countError } = await supabase
      .from('excluded_tokens_bot2')
      .select('created_at');
    if (countError) {
      console.error('Error fetching excluded_tokens_bot2 stats:', countError.message);
      return;
    }
    const totalExclusions = allExclusions.length;
    const recentExclusions = allExclusions.filter(ex => new Date(ex.created_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)).length;
    console.log(`Excluded tokens: ${totalExclusions} total, ${recentExclusions} added in last 24 hours`);
  } catch (error) {
    console.error('Unexpected error pruning excluded_tokens_bot2:', error.message);
  }
}

process.on('SIGINT', async () => {
  console.log('SIGINT: Saving active trades and exiting...');
  await saveActiveTrades();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('SIGTERM: Saving active trades and exiting...');
  await saveActiveTrades();
  process.exit(0);
});

process.on('uncaughtException', async (error) => {
  console.error('Uncaught Exception:', error.message, error.stack);
  await saveActiveTrades();
  process.exit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error('Unhandled Rejection:', reason);
  await saveActiveTrades();
  process.exit(1);
});

async function loadCache() {
  try {
    const data = await fs.readFile(CACHE_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return {};
  }
}

async function saveCache(cache) {
  try {
    await fs.writeFile(CACHE_FILE, JSON.stringify(cache, null, 2));
  } catch (error) {
    console.error('Error saving cache:', error.message);
  }
}

async function getTokenProgramAndExtensions(mint, connection) {
  try {
    console.log(`Checking token program and extensions for mint: ${mint.toBase58()}`);
    const mintInfo = await connection.getAccountInfo(mint);
    if (!mintInfo) {
      console.error(`Mint ${mint.toBase58()} does not exist on-chain`);
      return { program: null, hasExtensions: false, hasTransferFees: false };
    }
    let program;
    if (mintInfo.owner.equals(TOKEN_PROGRAM_ID)) {
      console.log(`Mint ${mint.toBase58()} uses standard SPL Token Program`);
      program = TOKEN_PROGRAM_ID;
    } else if (mintInfo.owner.equals(TOKEN_2022_PROGRAM_ID)) {
      console.log(`Mint ${mint.toBase58()} uses Token-2022 Program`);
      program = TOKEN_2022_PROGRAM_ID;
    } else {
      console.error(`Mint ${mint.toBase58()} uses unsupported program: ${mintInfo.owner.toBase58()}`);
      return { program: null, hasExtensions: false, hasTransferFees: false };
    }

    let hasExtensions = false;
    let hasTransferFees = false;
    if (program.equals(TOKEN_2022_PROGRAM_ID)) {
      console.warn(`Mint ${mint.toBase58()} uses Token-2022 Program, checking for extensions`);
      hasExtensions = true;
      try {
        const mintAccount = await splToken.getMint(connection, mint, 'confirmed', TOKEN_2022_PROGRAM_ID);
        const transferFeeConfig = await splToken.getTransferFeeConfig(mintAccount);
        if (transferFeeConfig) {
          console.log(`Mint ${mint.toBase58()} has transfer fee extension`);
          hasTransferFees = true;
        } else {
          console.log(`Mint ${mint.toBase58()} has no transfer fee extension`);
        }
      } catch (error) {
        console.error(`Error checking transfer fee extension for mint ${mint.toBase58()}:`, error.message);
      }
    }

    return { program, hasExtensions, hasTransferFees };
  } catch (error) {
    console.error(`Error checking token program for mint ${mint.toBase58()}:`, error.message);
    return { program: null, hasExtensions: false, hasTransferFees: false };
  }
}

async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner) {
  const maxRetries = 3;
  let attempt = 1;

  const { program: tokenProgram, hasExtensions } = await getTokenProgramAndExtensions(mint, connection);
  if (!tokenProgram) {
    throw new Error(`Invalid or unsupported token program for mint ${mint.toBase58()}`);
  }

  if (hasExtensions) {
    console.warn(`Mint ${mint.toBase58()} has Token-2022 extensions, which may require special handling`);
  }

  while (attempt <= maxRetries) {
    try {
      console.log(`Creating/checking token account for mint ${mint.toBase58()} using program ${tokenProgram.toBase58()} (attempt ${attempt})`);

      const balance = await connection.getBalance(payer.publicKey);
      if (balance < ATA_RENT_LAMPORTS) {
        throw new Error(`Insufficient balance for ATA rent: ${balance / LAMPORTS_PER_SOL} SOL available, need ${ATA_RENT_LAMPORTS / LAMPORTS_PER_SOL} SOL`);
      }

      const associatedTokenAddress = await splToken.getAssociatedTokenAddress(mint, owner, false, tokenProgram);
      try {
        const accountInfo = await splToken.getAccount(connection, associatedTokenAddress, 'confirmed', tokenProgram);
        console.log(`Existing token account found: ${accountInfo.address.toBase58()}, balance: ${accountInfo.amount} tokens`);
        return { address: accountInfo.address, amount: accountInfo.amount };
      } catch (error) {
        if (error.name !== 'TokenAccountNotFoundError') {
          console.error(`Error checking existing ATA ${associatedTokenAddress.toBase58()}:`, error.message);
        }
      }

      const transaction = new Transaction().add(
        splToken.createAssociatedTokenAccountInstruction(
          payer.publicKey,
          associatedTokenAddress,
          owner,
          mint,
          tokenProgram
        )
      );
      const { blockhash } = await connection.getLatestBlockhash('confirmed');
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = payer.publicKey;

      const signature = await sendAndConfirmTransaction(connection, transaction, [payer], { commitment: 'confirmed' });
      console.log(`Created token account: ${associatedTokenAddress.toBase58()}, Tx: ${signature}`);

      const accountInfo = await splToken.getAccount(connection, associatedTokenAddress, 'confirmed', tokenProgram);
      console.log(`Token account balance: ${accountInfo.amount} tokens`);
      return { address: accountInfo.address, amount: accountInfo.amount };
    } catch (error) {
      console.error(`Attempt ${attempt} failed to create token account for mint ${mint.toBase58()}:`, error.message, error.stack);
      if (error instanceof SendTransactionError) {
        console.error('Transaction logs:', error.logs);
      }
      if (attempt === maxRetries) {
        throw new Error(`Failed to create token account after ${maxRetries} attempts: ${error.message}`);
      }
      attempt++;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

async function isTokenExcluded(tokenAddress) {
  const maxRetries = 3;
  let attempt = 1;
  while (attempt <= maxRetries) {
    try {
      console.log(`Checking if token ${tokenAddress} is excluded (attempt ${attempt})`);
      const { data, error } = await supabase
        .from('excluded_tokens_bot2')
        .select('token_address')
        .eq('token_address', tokenAddress);
      if (error) {
        console.error(`Supabase error checking excluded token ${tokenAddress}:`, error.message);
        throw error;
      }
      const isExcluded = data.length > 0;
      console.log(`Token ${tokenAddress} excluded: ${isExcluded}`);
      return isExcluded;
    } catch (error) {
      console.error(`Attempt ${attempt} failed for ${tokenAddress}:`, error.message);
      if (attempt === maxRetries) {
        console.error(`Failed to check excluded status for ${tokenAddress} after ${maxRetries} attempts`);
        return false;
      }
      attempt++;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
  return false;
}

async function addTokenToExcluded(tokenAddress) {
  try {
    console.log(`Adding ${tokenAddress} to excluded tokens`);
    const { error } = await supabase
      .from('excluded_tokens_bot2')
      .upsert({ token_address: tokenAddress }, { onConflict: 'token_address' });
    if (error) {
      console.error(`Error adding ${tokenAddress} to excluded_tokens_bot2:`, error.message);
      return false;
    }
    console.log(`Successfully added ${tokenAddress} to excluded_tokens_bot2`);
    return true;
  } catch (error) {
    console.error(`Unexpected error adding ${tokenAddress} to excluded_tokens_bot2:`, error.message);
    return false;
  }
}

async function hasMarketCapExceededThreshold(tokenAddress) {
  try {
    console.log(`Checking if ${tokenAddress} exceeded ${MAX_HISTORICAL_MARKET_CAP} USD market cap in last 24h`);
    const cache = await loadCache();
    const cacheKey = `${tokenAddress}_dexscreener`;
    const cached = cache[cacheKey];

    if (cached && cached.timestamp > Date.now() - HISTORICAL_CACHE_TTL) {
      console.log(`Cached result for ${tokenAddress}: ${cached.exceeded}`);
      return cached.exceeded;
    }

    const supply = await getCirculatingSupply(tokenAddress);
    console.log(`Circulating supply for ${tokenAddress}: ${supply}`);

    // Fetch price history from Dexscreener
    const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`;
    let maxCurrentPrice = 0;
    let maxHigh24hPrice = 0;
    let high24hFound = false;

    try {
      const res = await axios.get(url, { timeout: 5000 });
      console.log(`Dexscreener response for ${tokenAddress}:`, JSON.stringify(res.data, null, 2));
      const pairs = res.data.pairs || [];

      if (!pairs || pairs.length === 0) {
        console.error(`Dexscreener has no data for ${tokenAddress}. Excluding token.`);
        await addTokenToExcluded(tokenAddress);
        return true;
      }

      for (const pair of pairs) {
        const price = parseFloat(pair.priceUsd) || 0;
        const high24h = parseFloat(pair.priceHigh24h) || 0;

        if (price > maxCurrentPrice) {
          maxCurrentPrice = price;
        }

        if (high24h > 0) {
          high24hFound = true;
          if (high24h > maxHigh24hPrice) {
            maxHigh24hPrice = high24h;
          }
        }
      }

      if (!high24hFound) {
        console.warn(`No 24h high price found for ${tokenAddress}, using max current price: $${maxCurrentPrice.toFixed(8)}`);
        maxHigh24hPrice = maxCurrentPrice;
      }

      console.log(`Dexscreener: Max Current=$${maxCurrentPrice.toFixed(8)}, Max 24hHigh=$${maxHigh24hPrice.toFixed(8)} for ${tokenAddress}`);
    } catch (error) {
      console.error(`Dexscreener error for ${tokenAddress}: ${error.message}`);
      if (error.response?.status === 429) {
        console.log(`Rate limit hit, retrying after 10 seconds...`);
        await new Promise(resolve => setTimeout(resolve, 10000));
        return await hasMarketCapExceededThreshold(tokenAddress); // Retry once
      }
      console.error(`No 24h price data for ${tokenAddress}. Excluding token.`);
      await addTokenToExcluded(tokenAddress);
      return true;
    }

    if (!maxHigh24hPrice || maxHigh24hPrice === 0) {
      console.error(`No valid 24h price data for ${tokenAddress}. Excluding token.`);
      await addTokenToExcluded(tokenAddress);
      return true;
    }

    const peakMarketCap = maxHigh24hPrice * supply;
    const exceeded = peakMarketCap > MAX_HISTORICAL_MARKET_CAP;

    console.log(`Peak Market Cap for ${tokenAddress}: $${peakMarketCap.toFixed(2)}`);

    if (exceeded) {
      console.log(`Token ${tokenAddress} exceeded ${MAX_HISTORICAL_MARKET_CAP} USD market cap`);
      await addTokenToExcluded(tokenAddress);
    } else {
      console.log(`Token ${tokenAddress} stayed below ${MAX_HISTORICAL_MARKET_CAP} USD market cap`);
    }

    cache[cacheKey] = { exceeded, timestamp: Date.now() };
    await saveCache(cache);
    return exceeded;
  } catch (error) {
    console.error(`Error checking market cap for ${tokenAddress}: ${error.message}`);
    console.error(`Excluding token ${tokenAddress} for safety.`);
    await addTokenToExcluded(tokenAddress);
    return true;
  }
}

async function getRecentTokens() {
  try {
    console.log('Fetching tokens with active boosts from DEXScreener...');
    let tokens = [];
    let filteredOut = [];

    console.log('Fetching from /token-boosts/latest/v1...');
    const latestBoostResponse = await axios.get(`${DEXSCREENER_API}/token-boosts/latest/v1`, {
      headers: { 'Accept': 'application/json' },
    });

    console.log('Fetching from /token-boosts/top/v1...');
    const topBoostResponse = await axios.get(`${DEXSCREENER_API}/token-boosts/top/v1`, {
      headers: { 'Accept': 'application/json' },
    });

    const boostedTokens = [
      ...(Array.isArray(latestBoostResponse.data) ? latestBoostResponse.data : []),
      ...(Array.isArray(topBoostResponse.data) ? topBoostResponse.data : []),
    ];
    console.log(`Fetched ${boostedTokens.length} boosted tokens from DEXScreener`);
    if (boostedTokens.length === 0) {
      console.log('No boosted tokens found from either endpoint.');
      return [];
    }

    const uniqueBoostedTokens = Array.from(
      new Map(boostedTokens.map(token => [token.tokenAddress, token])).values()
    );
    console.log(`Found ${uniqueBoostedTokens.length} unique boosted tokens`);

    const solanaBoosted = uniqueBoostedTokens.filter(token => token.chainId === 'solana');
    console.log(`Found ${solanaBoosted.length} Solana boosted tokens`);
    if (solanaBoosted.length === 0) {
      console.log('No boosted Solana tokens found.');
      return [];
    }

    const batchSize = 200;
    const batches = [];
    for (let i = 0; i < solanaBoosted.length; i += batchSize) {
      batches.push(solanaBoosted.slice(i, i + batchSize).map(token => token.tokenAddress));
    }

    for (const batch of batches) {
      try {
        const response = await axios.get(`${DEXSCREENER_API}/tokens/v1/solana/${batch.join(',')}`, {
          headers: { 'Accept': 'application/json' },
        });
        console.log(`Batch response for ${batch.length} tokens`);

        const tokensData = Array.isArray(response.data) ? response.data : [];
        if (tokensData.length === 0) {
          console.log(`No token data returned for batch: ${batch}`);
          continue;
        }

        for (const token of tokensData) {
          // Check if baseToken and baseToken.address exist
          if (!token.baseToken || !token.baseToken.address) {
            console.log(`Skipping token: missing baseToken or baseToken.address`, token);
            filteredOut.push({
              address: 'unknown',
              dexId: token.dexId || 'unknown',
              boosts: token.boosts?.active || 0,
              reason: 'missing baseToken or baseToken.address',
            });
            continue;
          }

          const hasBoost = token.boosts?.active > 0;
          if (!hasBoost) {
            filteredOut.push({
              address: token.baseToken.address,
              dexId: token.dexId,
              boosts: token.boosts?.active || 0,
              reason: `hasBoost=${hasBoost}`,
            });
            continue;
          }

          tokens.push({
            baseToken: {
              address: token.baseToken.address,
              name: token.baseToken.name || 'Unknown',
              symbol: token.baseToken.symbol || 'Unknown',
            },
            priceUsd: token.priceUsd,
            boosts: { active: token.boosts.active },
            dexId: token.dexId,
          });
        }
        console.log(`Fetched ${tokens.length} tokens from batch`);
      } catch (error) {
        console.error(`Error fetching batch from DEXScreener:`, error.message);
      }
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    console.log(`Found ${tokens.length} tokens with active boosts:`, tokens.map(t => t.baseToken.address));
    console.log(`Filtered out tokens:`, filteredOut);
    return tokens;
  } catch (error) {
    console.error('Error fetching tokens:', error.message);
    return [];
  }
}
        async function monitorTelegramTokens() {
  console.log(`Starting Telegram bot to monitor ${TELEGRAM_CHANNEL}...`);

  telegramBot.on('message', async (msg) => {
    if (msg.chat.username !== TELEGRAM_CHANNEL && msg.chat.title !== TELEGRAM_CHANNEL) return;

    const text = msg.text || '';
    const addresses = text.match(SOLANA_ADDRESS_REGEX) || [];

    for (const address of addresses) {
      try {
        const mint = new PublicKey(address);
        const mintInfo = await connection.getAccountInfo(mint);
        if (mintInfo && (mintInfo.owner.equals(TOKEN_PROGRAM_ID) || mintInfo.owner.equals(TOKEN_2022_PROGRAM_ID))) {
          console.log(`Found token address in Telegram: ${address}`);

          const { data } = await supabase
            .from('telegram_tokens_bot2')
            .select('token_address')
            .eq('token_address', address);
          if (data.length > 0) {
            console.log(`Token ${address} already processed`);
            continue;
          }

          await supabase.from('telegram_tokens_bot2').insert({
            token_address: address,
            source: TELEGRAM_CHANNEL,
            timestamp: new Date().toISOString(),
            processed: false,
          });
          console.log(`Logged token ${address} to Supabase for trading bot processing`);
        } else {
          console.log(`Address ${address} is not a valid token mint, skipping`);
        }
      } catch (error) {
        console.error(`Error processing address ${address}:`, error.message);
      }
    }
  });
}

async function getTelegramTokens() {
  try {
    const { data, error } = await supabase
      .from('telegram_tokens_bot2')
      .select('token_address')
      .eq('processed', false);
    if (error) {
      console.error('Error fetching Telegram tokens:', error.message);
      return [];
    }
    console.log(`Found ${data.length} unprocessed Telegram tokens`);
    return data.map(item => ({
      baseToken: {
        address: item.token_address,
        name: 'Unknown',
        symbol: 'Unknown',
      },
      marketCap: 0,
      priceUsd: '0',
      boosts: { active: 1 },
      dexId: 'telegram',
    }));
  } catch (error) {
    console.error('Error in getTelegramTokens:', error.message);
    return [];
  }
}

async function getEligibleTokens() {
  try {
    const cache = await loadCache();
    const newCache = { ...cache };

    const dexscreenerTokens = await getRecentTokens();
    const telegramTokens = await getTelegramTokens();

    const tokens = [...dexscreenerTokens, ...telegramTokens];
    if (tokens.length === 0) {
      console.log('No eligible tokens found.');
      return [];
    }

    const eligibleTokens = [];
    let excludedCount = 0;
    let lowMarketCapCount = 0;
    let highMarketCapCount = 0;
    let highHistoricalMarketCapCount = 0;

    const validTokens = [];
    for (const token of tokens) {
      const tokenAddress = token.baseToken.address;

      try {
        new PublicKey(tokenAddress);
      } catch (error) {
        console.log(`Skipping ${tokenAddress}: invalid token address`);
        excludedCount++;
        await addTokenToExcluded(tokenAddress);
        continue;
      }

      // Filter out tokens whose address doesn't end with 'pump'
      if (!tokenAddress.toLowerCase().endsWith('pump')) {
        console.log(`Skipping ${tokenAddress}: token address does not end with 'pump'`);
        excludedCount++;
        await addTokenToExcluded(tokenAddress);
        continue;
      }

      if (tokenAddress.toLowerCase().endsWith('rev')) {
        console.log(`Skipping ${tokenAddress}: token address ends with 'rev'`);
        excludedCount++;
        await addTokenToExcluded(tokenAddress);
        continue;
      }

      const isExcluded = await isTokenExcluded(tokenAddress);
      if (isExcluded) {
        console.log(`Skipping ${tokenAddress}: already traded`);
        excludedCount++;
        continue;
      }

      validTokens.push(token);
    }

    const tokenAddresses = validTokens.map(token => token.baseToken.address);
    let prices = {};
    if (tokenAddresses.length > 0) {
      try {
        prices = await getMultiTokenPrices(tokenAddresses);
      } catch (error) {
        console.error('Error fetching prices from Jupiter:', error.message);
        return [];
      }
    }

    for (const token of validTokens) {
      const tokenAddress = token.baseToken.address;

      const hasHighHistoricalMarketCap = await hasMarketCapExceededThreshold(tokenAddress);
      if (hasHighHistoricalMarketCap) {
        console.log(`Skipping ${tokenAddress}: historical market cap exceeded ${MAX_HISTORICAL_MARKET_CAP} USD`);
        highHistoricalMarketCapCount++;
        await addTokenToExcluded(tokenAddress);
        continue;
      }

      let supply;
      try {
        supply = await getCirculatingSupply(tokenAddress);
      } catch (error) {
        console.error(`Skipping ${tokenAddress}: failed to fetch circulating supply`);
        continue;
      }

      const price = prices[tokenAddress];
      if (!price) {
        console.log(`Skipping ${tokenAddress}: no price data available`);
        continue;
      }
      const marketCap = price * supply;
      console.log(`Token ${tokenAddress}: price=$${price}, supply=${supply}, marketCap=$${marketCap}`);

      if (marketCap < MIN_MARKET_CAP) {
        console.log(`Skipping ${tokenAddress}: marketCap=${marketCap} below minimum ${MIN_MARKET_CAP}`);
        lowMarketCapCount++;
        continue;
      }
      if (marketCap > MAX_MARKET_CAP) {
        console.log(`Skipping ${tokenAddress}: marketCap=${marketCap} above maximum ${MAX_MARKET_CAP}`);
        highMarketCapCount++;
        continue;
      }

      const isTelegramToken = token.dexId === 'telegram';
      const boostsActive = token.boosts?.active || 0;
      const status = {
        tokenAddress,
        marketCap,
        boosted: isTelegramToken ? true : boostsActive > 0,
        boostsActive,
        dexId: token.dexId,
      };

      console.log(`Token ${tokenAddress}: marketCap=${marketCap}, telegram=${isTelegramToken}, boosted=${status.boosted}, boosts=${boostsActive}`);

      const tokenData = {
        baseToken: {
          address: tokenAddress,
          name: token.baseToken.name,
          symbol: token.baseToken.symbol,
        },
        marketCap: marketCap,
        priceUsd: token.priceUsd.toString(),
        boosts: { active: boostsActive },
        dexId: token.dexId,
      };
      eligibleTokens.push(tokenData);
      newCache[tokenAddress] = { data: tokenData, status, timestamp: Date.now() };
      console.log(`Eligible token: ${tokenAddress} (marketCap=${marketCap}, telegram=${isTelegramToken}, boosts=${boostsActive})`);

      if (isTelegramToken) {
        await supabase.from('telegram_tokens_bot2').update({
          processed: true,
        }).eq('token_address', tokenAddress);
      }
    }

    await saveCache(newCache);

    console.log(`Eligible tokens for trading: ${eligibleTokens.length}, skipped ${excludedCount} excluded tokens, ${lowMarketCapCount} low market cap tokens, ${highMarketCapCount} high market cap tokens, ${highHistoricalMarketCapCount} high historical market cap tokens`);
    return eligibleTokens;
  } catch (error) {
    console.error('Error in getEligibleTokens:', error.message);
    return [];
  }
}

async function buyToken(tokenData) {
  try {
    const tokenAddress = tokenData.baseToken.address;
    console.log(`Attempting to buy token ${tokenAddress}...`);

    const balance = await connection.getBalance(wallet.publicKey);
    if (balance < MIN_TRADE_BALANCE) {
      console.error(`Insufficient balance: ${balance / LAMPORTS_PER_SOL} SOL, required: ${MIN_TRADE_BALANCE / LAMPORTS_PER_SOL} SOL`);
      return false;
    }

    const mint = new PublicKey(tokenAddress);
    const tokenAccountInfo = await getOrCreateAssociatedTokenAccount(connection, wallet, mint, wallet.publicKey);
    const tokenAccount = tokenAccountInfo.address;

    const quoteResponse = await axios.get(`${JUPITER_API}/quote`, {
      params: {
        inputMint: 'So11111111111111111111111111111111111111112',
        outputMint: tokenAddress,
        amount: BUY_AMOUNT,
        slippageBps: 100,
      },
      timeout: 5000,
    });

    const quote = quoteResponse.data;
    if (!quote || !quote.data || quote.data.length === 0) {
      console.error(`No valid swap routes found for ${tokenAddress}`);
      await addTokenToExcluded(tokenAddress);
      return false;
    }

    const swapResponse = await axios.post(`${JUPITER_API}/swap`, {
      quoteResponse: quote.data[0],
      userPublicKey: wallet.publicKey.toBase58(),
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: PRIORITY_FEE_LAMPORTS,
    }, {
      timeout: 10000,
    });

    const swapData = swapResponse.data;
    if (!swapData.swapTransaction) {
      console.error(`No swap transaction returned for ${tokenAddress}`);
      await addTokenToExcluded(tokenAddress);
      return false;
    }

    const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(swapTransactionBuf);
    transaction.sign([wallet]);

    const signature = await connection.sendRawTransaction(transaction.serialize(), {
      skipPreflight: true,
      maxRetries: 3,
    });

    const confirmation = await connection.confirmTransaction(signature, 'confirmed');
    if (confirmation.value.err) {
      console.error(`Transaction failed for ${tokenAddress}:`, confirmation.value.err);
      await addTokenToExcluded(tokenAddress);
      return false;
    }

    console.log(`Bought ${tokenAddress}, Tx: ${signature}`);
    const updatedAccountInfo = await splToken.getAccount(connection, tokenAccount, 'confirmed');
    const tokenAmount = updatedAccountInfo.amount;

    const buyPrice = parseFloat(tokenData.priceUsd);
    const { data: insertData, error } = await supabase
      .from('trades_bot2')
      .insert({
        wallet_address: wallet.publicKey.toBase58(),
        token_address: tokenAddress,
        token_account: tokenAccount.toBase58(),
        buy_price_usd: buyPrice,
        buy_timestamp: new Date().toISOString(),
        status: 'open',
        token_amount: tokenAmount.toString(),
      })
      .select('id')
      .single();

    if (error) {
      console.error(`Error saving trade for ${tokenAddress}:`, error.message);
      return false;
    }

    const trade = {
      tradeId: insertData.id,
      tokenAddress,
      buyPrice,
      buyTime: Date.now(),
      tokenAccount,
      tokenAmount,
      partialSell: false,
    };

    activeTrades.push(trade);
    console.log(`Trade recorded for ${tokenAddress}, tradeId: ${trade.tradeId}, amount: ${tokenAmount}`);

    monitorAndSell(trade).catch(error => console.error(`Error monitoring ${tokenAddress}:`, error.message));
    return true;
  } catch (error) {
    console.error(`Error buying ${tokenData.baseToken.address}:`, error.message);
    await addTokenToExcluded(tokenData.baseToken.address);
    return false;
  }
}

async function monitorAndSell(trade) {
  try {
    console.log(`Monitoring trade ${trade.tradeId} for ${trade.tokenAddress}`);
    const startTime = trade.buyTime;
    let partialSell = trade.partialSell;

    while (true) {
      await new Promise(resolve => setTimeout(resolve, PRICE_CHECK_INTERVAL));

      let currentPrice;
      try {
        currentPrice = await getTokenPrice(trade.tokenAddress);
      } catch (error) {
        console.error(`Error fetching price for ${trade.tokenAddress}:`, error.message);
        continue;
      }

      const supply = await getCirculatingSupply(trade.tokenAddress);
      const marketCap = currentPrice * supply;
      console.log(`Monitoring ${trade.tokenAddress}: CurrentPrice=$${currentPrice.toFixed(8)}, MarketCap=$${marketCap.toFixed(2)}`);

      // FIXED: Ensure profitPercent is always a valid number to prevent undefined
      const buyPrice = trade.buyPrice || 0;
      const profitPercent = (buyPrice !== 0 && !isNaN(currentPrice)) 
        ? ((currentPrice - buyPrice) / buyPrice * 100).toFixed(2) 
        : 0;

      const { error } = await supabase
        .from('trades_bot2')
        .update({
          current_price_usd: currentPrice,
          profit_percentage: parseFloat(profitPercent),
          market_cap: marketCap,
          status: partialSell ? 'partial_sold' : 'open',
        })
        .eq('id', trade.tradeId);

      if (error) {
        console.error(`Error updating trade ${trade.tradeId}:`, error.message);
        continue;
      }

      console.log(`Trade ${trade.tradeId}: Profit=${profitPercent}%, MarketCap=$${marketCap.toFixed(2)}, Status=${partialSell ? 'partial_sold' : 'open'}`);

      if (marketCap > MARKET_CAP_SELL_THRESHOLD && !partialSell) {
        console.log(`Market cap for ${trade.tokenAddress} exceeded ${MARKET_CAP_SELL_THRESHOLD} USD, selling 75%...`);
        const sold = await sellToken(trade, 0.75);
        if (sold) {
          partialSell = true;
          trade.partialSell = true;
          console.log(`Partial sell completed for ${trade.tokenAddress}`);
        } else {
          console.error(`Partial sell failed for ${trade.tokenAddress}`);
        }
      }

      if (parseFloat(profitPercent) >= PROFIT_TARGET && partialSell) {
        console.log(`Profit target ${PROFIT_TARGET}% reached for ${trade.tokenAddress}, selling remaining...`);
        const sold = await sellToken(trade, 1.0);
        if (sold) {
          console.log(`Full sell completed for ${trade.tokenAddress}`);
          break;
        }
      }

      if (parseFloat(profitPercent) <= STOP_LOSS) {
        console.log(`Stop loss ${STOP_LOSS}% hit for ${trade.tokenAddress}, selling all...`);
        const sold = await sellToken(trade, 1.0);
        if (sold) {
          console.log(`Stop loss sell completed for ${trade.tokenAddress}`);
          break;
        }
      }

      const holdTime = Date.now() - startTime;
      if (holdTime > HOLD_DURATION) {
        console.log(`Hold duration ${HOLD_DURATION / 1000}s exceeded for ${trade.tokenAddress}, selling all...`);
        const sold = await sellToken(trade, 1.0);
        if (sold) {
          console.log(`Hold duration sell completed for ${trade.tokenAddress}`);
          break;
        }
      }
    }

    activeTrades = activeTrades.filter(t => t.tradeId !== trade.tradeId);
    console.log(`Trade ${trade.tradeId} for ${trade.tokenAddress} completed and removed from active trades`);
  } catch (error) {
    console.error(`Error monitoring trade ${trade.tradeId} for ${trade.tokenAddress}:`, error.message);
    await supabase
      .from('trades_bot2')
      .update({
        status: 'failed',
        error_message: error.message,
      })
      .eq('id', trade.tradeId);
    activeTrades = activeTrades.filter(t => t.tradeId !== trade.tradeId);
  }
}

async function sellToken(trade, fraction) {
  try {
    console.log(`Selling ${fraction * 100}% of ${trade.tokenAddress} (tradeId: ${trade.tradeId})...`);

    const accountInfo = await splToken.getAccount(connection, trade.tokenAccount, 'confirmed');
    const tokenAmount = accountInfo.amount;
    const sellAmount = Math.floor(Number(tokenAmount) * fraction);

    if (sellAmount <= 0) {
      console.error(`Invalid sell amount: ${sellAmount} for ${trade.tokenAddress}`);
      return false;
    }

    const balance = await connection.getBalance(wallet.publicKey);
    if (balance < MIN_SELL_FEE_LAMPORTS) {
      console.error(`Insufficient balance for sell fees: ${balance / LAMPORTS_PER_SOL} SOL, required: ${MIN_SELL_FEE_LAMPORTS / LAMPORTS_PER_SOL} SOL`);
      return false;
    }

    const quoteResponse = await axios.get(`${JUPITER_API}/quote`, {
      params: {
        inputMint: trade.tokenAddress,
        outputMint: 'So11111111111111111111111111111111111111112',
        amount: sellAmount,
        slippageBps: 100,
      },
      timeout: 5000,
    });

    const quote = quoteResponse.data;
    if (!quote || !quote.data || quote.data.length === 0) {
      console.error(`No valid swap routes found for ${trade.tokenAddress}`);
      return false;
    }

    const swapResponse = await axios.post(`${JUPITER_API}/swap`, {
      quoteResponse: quote.data[0],
      userPublicKey: wallet.publicKey.toBase58(),
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: PRIORITY_FEE_LAMPORTS,
    }, {
      timeout: 10000,
    });

    const swapData = swapResponse.data;
    if (!swapData.swapTransaction) {
      console.error(`No swap transaction returned for ${trade.tokenAddress}`);
      return false;
    }

    const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(swapTransactionBuf);
    transaction.sign([wallet]);

    const signature = await connection.sendRawTransaction(transaction.serialize(), {
      skipPreflight: true,
      maxRetries: 3,
    });

    const confirmation = await connection.confirmTransaction(signature, 'confirmed');
    if (confirmation.value.err) {
      console.error(`Sell transaction failed for ${trade.tokenAddress}:`, confirmation.value.err);
      return false;
    }

    console.log(`Sold ${fraction * 100}% of ${trade.tokenAddress}, Tx: ${signature}`);

    const currentPrice = await getTokenPrice(trade.tokenAddress);
    const profitPercent = trade.buyPrice !== 0 ? ((currentPrice - trade.buyPrice) / trade.buyPrice * 100).toFixed(2) : 0;
    const totalProfit = (currentPrice - trade.buyPrice) * (sellAmount / Math.pow(10, 9));

    const status = fraction === 1.0 ? 'closed' : 'partial_sold';
    const { error } = await supabase
      .from('trades_bot2')
      .update({
        sell_price_usd: currentPrice,
        profit_percentage: parseFloat(profitPercent),
        total_profit_usd: totalProfit,
        sell_timestamp: new Date().toISOString(),
        status,
      })
      .eq('id', trade.tradeId);

    if (error) {
      console.error(`Error updating trade ${trade.tradeId} after sell:`, error.message);
      return false;
    }

    console.log(`Trade ${trade.tradeId} updated: Sold ${sellAmount} tokens, Profit=${profitPercent}%, TotalProfit=$${totalProfit.toFixed(2)}, Status=${status}`);
    return true;
  } catch (error) {
    console.error(`Error selling ${trade.tokenAddress}:`, error.message);
    return false;
  }
}

async function startBot() {
  try {
    console.log('Starting Moon Bot...');
    await loadActiveTrades();
    await pruneExcludedTokens();
    await monitorTelegramTokens();

    while (true) {
      try {
        console.log('Checking for new eligible tokens...');
        const tokens = await getEligibleTokens();
        if (tokens.length === 0) {
          console.log('No eligible tokens found, waiting 30 seconds...');
          await new Promise(resolve => setTimeout(resolve, 30 * 1000));
          continue;
        }

        const balance = await connection.getBalance(wallet.publicKey);
        console.log(`Wallet balance: ${balance / LAMPORTS_PER_SOL} SOL`);

        if (balance < MIN_TRADE_BALANCE) {
          console.log(`Balance below minimum (${MIN_TRADE_BALANCE / LAMPORTS_PER_SOL} SOL), waiting 60 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 60 * 1000));
          continue;
        }

        for (const token of tokens) {
          try {
            const tokenAddress = token.baseToken.address;
            console.log(`Evaluating token ${tokenAddress}...`);

            const { lockedPct, success } = await getLiquidityLockStatus(tokenAddress);
            if (!success) {
              console.log(`Skipping ${tokenAddress}: RugCheck failed`);
              await addTokenToExcluded(tokenAddress);
              continue;
            }

            if (lockedPct < 75) {
              console.log(`Skipping ${tokenAddress}: Liquidity lock ${lockedPct}% is below 75%`);
              await addTokenToExcluded(tokenAddress);
              continue;
            }

            const successBuy = await buyToken(token);
            if (successBuy) {
              console.log(`Successfully bought ${tokenAddress}`);
            } else {
              console.log(`Failed to buy ${tokenAddress}`);
            }
          } catch (error) {
            console.error(`Error processing ${token.baseToken.address}:`, error.message);
            await addTokenToExcluded(token.baseToken.address);
          }
        }

        console.log(`Waiting 30 seconds before next cycle...`);
        await new Promise(resolve => setTimeout(resolve, 30 * 1000));
      } catch (error) {
        console.error('Error in trading cycle:', error.message);
        await new Promise(resolve => setTimeout(resolve, 60 * 1000));
      }
    }
  } catch (error) {
    console.error('Fatal error in startBot:', error.message);
    process.exit(1);
  }
}

startBot().catch(error => {
  console.error('Error starting bot:', error.message);
  process.exit(1);
});
