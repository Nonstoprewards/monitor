<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun Bags Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-bold mb-4 text-center">Fun Bags Dashboard</h1>
        <div class="flex justify-end mb-4">
            <button id="sexyModeToggle" class="bg-blue-500 text-white px-4 py-2 rounded flex items-center">
                <i class="fas fa-moon mr-2"></i> Sexy Mode
            </button>
        </div>

        <!-- Monitored Coins Section -->
        <div class="mb-8">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">Monitored Coins</h2>
                <div class="flex items-center space-x-2">
                    <input id="funbags-monitoredFilter" type="text" placeholder="Filter by token..." class="border p-2 rounded">
                    <button id="funbags-monitoredRefreshBtn" class="bg-green-500 text-white px-4 py-2 rounded">Refresh</button>
                    <select id="funbags-monitoredPageSize" class="border p-2 rounded">
                        <option value="10">10 per page</option>
                        <option value="25">25 per page</option>
                        <option value="50">50 per page</option>
                    </select>
                </div>
            </div>
            <p id="funbags-monitored-status" class="text-gray-600 mb-2">Loading monitored coins...</p>
            <div class="overflow-x-auto">
                <table class="min-w-full bg-white border">
                    <thead>
                        <tr>
                            <th class="py-2 px-4 border-b" data-sort="token_name">Token <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="market_cap">Market Cap <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="current_price_usd">Current Price (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="lowest_market_cap">Lowest Market Cap <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="timestamp">Monitoring Start <span class="sort-icon">↕</span></th>
                        </tr>
                    </thead>
                    <tbody id="funbags-monitoredBody"></tbody>
                </table>
            </div>
            <div class="mt-4 flex justify-between items-center">
                <button id="funbags-monitoredPrevPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Previous</button>
                <span>Page <span id="funbags-monitoredCurrentPage">1</span></span>
                <button id="funbags-monitoredNextPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Next</button>
            </div>
            <div id="funbags-monitoredCards" class="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
        </div>

        <!-- Active Trades Section -->
        <div class="mb-8">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">Active Trades</h2>
                <div class="flex items-center space-x-2">
                    <input id="funbags-activeFilter" type="text" placeholder="Filter by token..." class="border p-2 rounded">
                    <button id="funbags-topRefreshBtn" class="bg-green-500 text-white px-4 py-2 rounded">Refresh</button>
                    <select id="funbags-activePageSize" class="border p-2 rounded">
                        <option value="10">10 per page</option>
                        <option value="25">25 per page</option>
                        <option value="50">50 per page</option>
                    </select>
                </div>
            </div>
            <p id="funbags-active-status" class="text-gray-600 mb-2">Loading active trades...</p>
            <div class="overflow-x-auto">
                <table class="min-w-full bg-white border">
                    <thead>
                        <tr>
                            <th class="py-2 px-4 border-b" data-sort="token_name">Token <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="buy_price_usd">Buy Price (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="current_price_usd">Current Price (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="market_cap">Market Cap <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="profit">Profit (%) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="buy_timestamp">Buy Time <span class="sort-icon">↕</span></th>
                        </tr>
                    </thead>
                    <tbody id="funbags-activeTradesBody"></tbody>
                </table>
            </div>
            <div class="mt-4 flex justify-between items-center">
                <button id="funbags-activePrevPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Previous</button>
                <span>Page <span id="funbags-activeCurrentPage">1</span></span>
                <button id="funbags-activeNextPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Next</button>
            </div>
            <div id="funbags-activeTradesCards" class="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            <button id="funbags-middleRefreshBtn" class="mt-4 bg-green-500 text-white px-4 py-2 rounded">Refresh</button>
        </div>

        <!-- Completed Trades Section -->
        <div class="mb-8">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">Completed Trades</h2>
                <div class="flex items-center space-x-2">
                    <input id="funbags-completedFilter" type="text" placeholder="Filter by token..." class="border p-2 rounded">
                    <select id="funbags-profitFilter" class="border p-2 rounded">
                        <option value="all">All Profits</option>
                        <option value="positive">Positive Profits</option>
                        <option value="negative">Negative Profits</option>
                    </select>
                    <button id="funbags-exportBtn" class="bg-blue-500 text-white px-4 py-2 rounded">Export CSV</button>
                    <select id="funbags-completedPageSize" class="border p-2 rounded">
                        <option value="10">10 per page</option>
                        <option value="25">25 per page</option>
                        <option value="50">50 per page</option>
                    </select>
                </div>
            </div>
            <p id="funbags-completed-status" class="text-gray-600 mb-2">Loading completed trades...</p>
            <div class="overflow-x-auto">
                <table class="min-w-full bg-white border">
                    <thead>
                        <tr>
                            <th class="py-2 px-4 border-b" data-sort="token_name">Token <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="buy_price_usd">Buy Price (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="sell_price_usd">Sell Price (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="profit">Profit (%) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="total_profit_usd">Total Profit (USD) <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="buy_timestamp">Buy Time <span class="sort-icon">↕</span></th>
                            <th class="py-2 px-4 border-b" data-sort="sell_timestamp">Sell Time <span class="sort-icon">↕</span></th>
                        </tr>
                    </thead>
                    <tbody id="funbags-completedTradesBody"></tbody>
                </table>
            </div>
            <div class="mt-4 flex justify-between items-center">
                <button id="funbags-completedPrevPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Previous</button>
                <span>Page <span id="funbags-completedCurrentPage">1</span></span>
                <button id="funbags-completedNextPage" class="bg-gray-300 px-4 py-2 rounded disabled:opacity-50">Next</button>
            </div>
            <div id="funbags-completedTradesCards" class="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            <div class="mt-4">
                <p class="text-lg font-semibold">Total Profit: <span id="funbags-totalProfit">$0.00</span></p>
                <button id="funbags-bottomRefreshBtn" class="bg-green-500 text-white px-4 py-2 rounded">Refresh</button>
            </div>
        </div>
    </div>
</body>
</html>
<style>
    body {
        font-family: Arial, sans-serif;
    }
    .container {
        max-width: 1200px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        text-align: left;
        padding: 12px;
    }
    th {
        background-color: #f4f4f4;
        cursor: pointer;
    }
    th:hover {
        background-color: #e0e0e0;
    }
    tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    tr:hover {
        background-color: #f1f1f1;
    }
    .sort-icon {
        display: inline-block;
        width: 12px;
        text-align: center;
    }
    .sort-asc .sort-icon::after {
        content: '↑';
    }
    .sort-desc .sort-icon::after {
        content: '↓';
    }
    .card {
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card p {
        margin: 8px 0;
    }
    .card-label {
        font-weight: bold;
        color: #555;
    }
    .loading::after {
        content: ' ⏳';
    }
    .profit-positive {
        color: green;
        font-weight: bold;
    }
    .profit-negative {
        color: red;
        font-weight: bold;
    }
    .disabled {
        pointer-events: none;
        opacity: 0.5;
    }
    .sexy {
        background-color: #1a1a1a;
        color: #fff;
    }
    .sexy h1, .sexy h2 {
        color: #ff69b4;
    }
    .sexy .bg-white {
        background-color: #2a2a2a;
        border-color: #444;
    }
    .sexy .bg-gray-100 {
        background-color: #1a1a1a;
    }
    .sexy .text-gray-600 {
        color: #ccc;
    }
    .sexy th {
        background-color: #333;
        color: #fff;
    }
    .sexy tr:nth-child(even) {
        background-color: #2f2f2f;
    }
    .sexy tr:hover {
        background-color: #3a3a3a;
    }
    .sexy .card {
        background-color: #2a2a2a;
        border-color: #444;
        box-shadow: 0 2px 4px rgba(255,105,180,0.2);
    }
    .sexy .card-label {
        color: #ff69b4;
    }
    .token-cell {
        display: flex;
        align-items: center;
        padding: 12px;
    }
    .token-icon {
        width: 24px;
        height: 24px;
        margin-left: 8px;
        vertical-align: middle;
        display: none;
    }
    .token-icon.loaded {
        display: inline-block;
    }
    .card .token-icon {
        margin-left: 8px;
        vertical-align: middle;
        display: none;
    }
    .card .token-icon.loaded {
        display: inline-block;
    }
    .sexy .token-cell a {
        color: #ff69b4;
    }
    .sexy .token-icon {
        filter: brightness(1.2);
    }
</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
    console.log('Script loaded');

    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM loaded');

        // Initialize Supabase client
        let supabase;
        try {
            supabase = window.supabase.createClient(
                'https://bprfbjsxbkitrbqszqpz.supabase.co',
                'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJwcmZianN4YmtpdHJicXN6cXB6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU4OTQzMzksImV4cCI6MjA2MTQ3MDMzOX0.Uc2iM_H3vEd4dnTLi_B2EncReqlYHXWyZ9zGHsXh4mM'
            );
            console.log('Supabase client initialized');
        } catch (error) {
            console.error('Error initializing Supabase:', error);
            alert('Failed to initialize Supabase. Check console for details.');
            return;
        }

        // Sorting and Filtering States
        const sortStates = {
            funbags: { active: {}, completed: {}, monitored: {} }
        };

        // Pagination States
        const pageStates = {
            funbags: { active: 1, completed: 1, monitored: 1 }
        };
        const pageSizes = {
            funbags: { active: 10, completed: 10, monitored: 10 }
        };

        // Cache for full dataset
        const dataCache = {
            funbags: { monitored: [], active: [], completed: [] }
        };

        // Cache for token metadata
        const tokenNameCache = new Map();

        // Retry mechanism for Supabase queries
        async function withRetry(fn, retries = 3, delay = 1000) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    if (attempt === retries) throw error;
                    console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms...`, error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Debounce function for button clicks
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        async function fetchTokenData(tokenAddress) {
            console.log(`Fetching token data for ${tokenAddress}`);
            if (tokenNameCache.has(tokenAddress)) {
                console.log(`Cache hit for ${tokenAddress}`);
                return tokenNameCache.get(tokenAddress);
            }

            try {
                if (!tokenAddress || typeof tokenAddress !== 'string' || tokenAddress.length < 10) {
                    throw new Error('Invalid token address');
                }

                // Check Supabase for metadata
                const { data: tokenState, error: tokenError } = await supabase
                    .from('token_states')
                    .select('token_address, token_name, icon_url')
                    .eq('token_address', tokenAddress)
                    .single();
                if (tokenError && !tokenError.message.includes('0 rows')) {
                    console.warn(`Supabase error for ${tokenAddress}:`, tokenError.message);
                }

                let name = tokenState?.token_name || null;
                let iconUrl = tokenState?.icon_url || null;
                let marketCap = 0;
                let price = 0;

                // Fetch from CoinGecko if metadata missing
                if (!name || !iconUrl) {
                    const coingeckoUrl = `https://api.coingecko.com/api/v3/coins/solana/contract/${tokenAddress}`;
                    const response = await fetch(coingeckoUrl);
                    if (response.ok) {
                        const data = await response.json();
                        name = data.name || data.symbol || null;
                        marketCap = data.market_data?.market_cap?.usd || 0;
                        price = data.market_data?.current_price?.usd || 0;
                        iconUrl = data.image?.thumb || null;

                        // Save to Supabase
                        if (name || iconUrl) {
                            const updateData = {};
                            if (name) updateData.token_name = name;
                            if (iconUrl) updateData.icon_url = iconUrl;
                            const { error: updateError } = await supabase
                                .from('token_states')
                                .update(updateData)
                                .eq('token_address', tokenAddress);
                            if (updateError) {
                                console.warn(`Failed to save metadata for ${tokenAddress}:`, updateError.message);
                            } else {
                                console.log(`Saved metadata for ${tokenAddress} to Supabase`);
                            }
                        }
                    } else {
                        console.warn(`CoinGecko API error for ${tokenAddress}: ${response.status}`);
                    }
                }

                // Fallback values
                const fallbackIcon = 'https://via.placeholder.com/24?text=C';
                const result = {
                    marketCap: marketCap || 0,
                    price: price || 0,
                    name: name || 'Unknown Token',
                    icon: iconUrl || fallbackIcon
                };
                tokenNameCache.set(tokenAddress, result);
                return result;
            } catch (error) {
                console.error(`Error fetching token data for ${tokenAddress}:`, error.message);
                const fallbackIcon = 'https://via.placeholder.com/24?text=C';
                const fallback = {
                    marketCap: 0,
                    price: 0,
                    name: 'Unknown Token',
                    icon: fallbackIcon
                };
                tokenNameCache.set(tokenAddress, fallback);
                return fallback;
            }
        }
                async function fetchMonitoredCoins() {
            console.log(`Fetching all monitored coins`);
            try {
                const { data: monitoredCoins, error, count } = await withRetry(async () => await supabase
                    .from('token_states')
                    .select('token_address, max_market_cap, lowest_market_cap, within_range_start_time, is_bonding, token_name, icon_url', { count: 'exact' })
                    .eq('monitoring', true)
                    .eq('bought', false)
                    .order('within_range_start_time', { ascending: false })
                );
                if (error) throw new Error(`Failed to fetch monitored coins: ${error.message}`);
                console.log('Monitored coins fetched:', monitoredCoins?.length || 'No coins');

                const coinsWithData = await Promise.all((monitoredCoins || []).map(async coin => {
                    const tokenData = await fetchTokenData(coin.token_address);
                    const marketCap = parseFloat(coin.max_market_cap) || tokenData.marketCap || 0;
                    const price = marketCap / 1_000_000_000;
                    return {
                        token_address: coin.token_address || '-',
                        token_name: coin.token_name || tokenData.name,
                        market_cap: marketCap,
                        current_price_usd: price,
                        lowest_market_cap: parseFloat(coin.lowest_market_cap) || 999999999,
                        timestamp: coin.within_range_start_time ? new Date(parseInt(coin.within_range_start_time)).toISOString() : new Date().toISOString(),
                        icon: coin.icon_url || tokenData.icon
                    };
                }));

                dataCache.funbags.monitored = coinsWithData;
                return { coins: coinsWithData, total: count || coinsWithData.length };
            } catch (error) {
                console.error('Error in fetchMonitoredCoins:', error);
                throw error;
            }
        }

        async function refreshMonitoredCoins(page = 1) {
            console.log(`Starting refreshMonitoredCoins, page ${page}`);
            const monitoredStatus = document.getElementById('funbags-monitored-status');
            const monitoredBody = document.getElementById('funbags-monitoredBody');
            const monitoredCards = document.getElementById('funbags-monitoredCards');
            const monitoredTable = monitoredBody?.closest('table');
            const monitoredFilterInput = document.getElementById('funbags-monitoredFilter');
            const prevPage = document.getElementById('funbags-monitoredPrevPage');
            const nextPage = document.getElementById('funbags-monitoredNextPage');
            const currentPageSpan = document.getElementById('funbags-monitoredCurrentPage');

            if (!monitoredStatus || !monitoredBody || !monitoredCards || !monitoredTable || !monitoredFilterInput || !prevPage || !nextPage || !currentPageSpan) {
                console.error('Missing DOM elements for monitored coins');
                monitoredStatus.textContent = 'Error: Missing DOM elements';
                return;
            }

            monitoredStatus.textContent = 'Loading monitored coins...';
            monitoredStatus.classList.add('loading');

            try {
                const { coins: fetchedCoins, total } = await fetchMonitoredCoins();
                console.log(`Fetched monitored coins: ${fetchedCoins.length}, total: ${total}`);

                let displayCoins = [...dataCache.funbags.monitored];
                const monitoredSort = { ...sortStates.funbags.monitored };
                if (Object.keys(monitoredSort).length > 0) {
                    const column = Object.keys(monitoredSort)[0];
                    const direction = monitoredSort[column];
                    console.log(`Sorting monitored coins by ${column} ${direction}`);
                    displayCoins.sort((a, b) => {
                        let aValue = a[column];
                        let bValue = b[column];
                        if (['market_cap', 'current_price_usd', 'lowest_market_cap'].includes(column)) {
                            aValue = parseFloat(aValue) || 0;
                            bValue = parseFloat(bValue) || 0;
                        } else if (column === 'timestamp') {
                            aValue = aValue ? new Date(aValue).getTime() : 0;
                            bValue = bValue ? new Date(bValue).getTime() : 0;
                        } else {
                            aValue = aValue ? aValue.toString().toLowerCase() : '';
                            bValue = bValue ? bValue.toString().toLowerCase() : '';
                        }
                        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                const start = (page - 1) * pageSizes.funbags.monitored;
                const end = start + pageSizes.funbags.monitored;
                displayCoins = displayCoins.slice(start, end);
                console.log(`Paginated monitored coins: start=${start}, end=${end}, coins=${displayCoins.length}`);

                monitoredBody.innerHTML = '';
                monitoredCards.innerHTML = '';
                if (displayCoins.length === 0) {
                    monitoredStatus.textContent = 'No monitored coins found';
                    monitoredCards.innerHTML = '<p>No monitored coins available.</p>';
                } else {
                    displayCoins.forEach(coin => {
                        const tokenAddress = coin.token_address || '-';
                        const tokenName = coin.token_name || '-';
                        const marketCap = coin.market_cap || 0;
                        const currentPrice = coin.current_price_usd || 0;
                        const lowestMarketCap = coin.lowest_market_cap || 999999999;
                        const timestamp = coin.timestamp ? new Date(coin.timestamp).toLocaleString() : '-';
                        const iconUrl = coin.icon || 'https://via.placeholder.com/24?text=C';

                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="token-cell">
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </td>
                            <td>$${marketCap.toLocaleString()}</td>
                            <td>$${currentPrice.toFixed(8)}</td>
                            <td>$${lowestMarketCap.toLocaleString()}</td>
                            <td>${timestamp}</td>
                        `;
                        monitoredBody.appendChild(row);

                        const card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `
                            <p><span class="card-label">Token:</span> 
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </p>
                            <p><span class="card-label">Market Cap:</span> $${marketCap.toLocaleString()}</p>
                            <p><span class="card-label">Current Price:</span> $${currentPrice.toFixed(8)}</p>
                            <p><span class="card-label">Lowest Market Cap:</span> $${lowestMarketCap.toLocaleString()}</p>
                            <p><span class="card-label">Monitoring Start:</span> ${timestamp}</p>
                        `;
                        monitoredCards.appendChild(card);
                    });
                    monitoredStatus.textContent = `Monitored coins loaded (${displayCoins.length}/${total})`;
                }

                currentPageSpan.textContent = page;
                prevPage.classList.toggle('disabled', page === 1);
                nextPage.classList.toggle('disabled', end >= dataCache.funbags.monitored.length);
                console.log(`Monitored pagination: page=${page}, total=${dataCache.funbags.monitored.length}`);

                const headers = monitoredTable.querySelectorAll('th[data-sort]');
                headers.forEach(header => {
                    header.classList.remove('sort-asc', 'sort-desc');
                    const icon = header.querySelector('.sort-icon');
                    if (icon) icon.innerHTML = '↕';
                });
                if (Object.keys(monitoredSort).length > 0) {
                    const column = Object.keys(monitoredSort)[0];
                    const direction = monitoredSort[column];
                    const header = monitoredTable.querySelector(`th[data-sort="${column}"]`);
                    if (header) {
                        header.classList.add(`sort-${direction}`);
                        header.querySelector('.sort-icon').innerHTML = direction === 'asc' ? '↑' : '↓';
                    }
                }

                const monitoredFilterValue = monitoredFilterInput.value || '';
                if (monitoredFilterValue) {
                    monitoredFilterInput.value = monitoredFilterValue;
                    monitoredFilterInput.dispatchEvent(new Event('input'));
                }
            } catch (error) {
                console.error('Error in refreshMonitoredCoins:', error);
                monitoredStatus.textContent = `Error loading monitored coins: ${error.message}`;
            } finally {
                monitoredStatus.classList.remove('loading');
            }
        }

        async function refreshTrades(activePage = 1, completedPage = 1) {
            console.log(`Starting refreshTrades, activePage: ${activePage}, completedPage: ${completedPage}`);
            const prefix = 'funbags';
            const activeStatus = document.getElementById(`${prefix}-active-status`);
            const completedStatus = document.getElementById(`${prefix}-completed-status`);
            const activeTradesBody = document.getElementById(`${prefix}-activeTradesBody`);
            const activeTradesCards = document.getElementById(`${prefix}-activeTradesCards`);
            const completedTradesBody = document.getElementById(`${prefix}-completedTradesBody`);
            const completedTradesCards = document.getElementById(`${prefix}-completedTradesCards`);
            const totalProfitElement = document.getElementById(`${prefix}-totalProfit`);
            const activeTable = activeTradesBody?.closest('table');
            const completedTable = completedTradesBody?.closest('table');
            const activePrevPage = document.getElementById(`${prefix}-activePrevPage`);
            const activeNextPage = document.getElementById(`${prefix}-activeNextPage`);
            const completedPrevPage = document.getElementById(`${prefix}-completedPrevPage`);
            const completedNextPage = document.getElementById(`${prefix}-completedNextPage`);
            const activeCurrentPage = document.getElementById(`${prefix}-activeCurrentPage`);
            const completedCurrentPage = document.getElementById(`${prefix}-completedCurrentPage`);

            if (!activeStatus || !activeTradesBody || !activeTradesCards || !completedStatus || !completedTradesBody || !completedTradesCards || !totalProfitElement || !activeTable || !completedTable || !activePrevPage || !activeNextPage || !completedPrevPage || !completedNextPage || !activeCurrentPage || !completedCurrentPage) {
                console.error(`Missing DOM elements for funbags`);
                activeStatus.textContent = 'Error: Missing DOM elements';
                completedStatus.textContent = 'Error: Missing DOM elements';
                return;
            }

            activeStatus.textContent = 'Loading active trades...';
            completedStatus.textContent = 'Loading completed trades...';
            activeStatus.classList.add('loading');
            completedStatus.classList.add('loading');

            try {
                await refreshMonitoredCoins(pageStates.funbags.monitored);

                console.log('Fetching active trades');
                const { data: tokenStates, error: tokenError, count: tokenCount } = await withRetry(async () => await supabase
                    .from('token_states')
                    .select('token_address, purchase_price, amount, sold50, buy_market_cap, token_name, icon_url', { count: 'exact' })
                    .eq('bought', true)
                    .gt('amount', 0)
                );
                if (tokenError) throw new Error(`Failed to fetch token states: ${error.message}`);
                console.log(`Active trades count: ${tokenCount}, data length: ${tokenStates?.length}`);

                const { data: buyLogs, error: buyLogError } = await withRetry(async () => await supabase
                    .from('bot_logs')
                    .select('token_address, timestamp')
                    .eq('event_type', 'buy')
                );
                if (buyLogError) throw new Error(`Failed to fetch buy logs: ${buyLogError.message}`);

                const { data: priceLogs, error: priceError } = await withRetry(async () => await supabase
                    .rpc('query_price_logs')
                );
                if (priceError) throw new Error(`Failed to fetch price logs: ${priceError.message}`);

                let activeTrades = [];
                const activePromises = (Array.isArray(tokenStates) ? tokenStates : []).map(async state => {
                    try {
                        if (!state.token_address) return null;
                        const tokenData = await fetchTokenData(state.token_address);
                        const buyLog = (Array.isArray(buyLogs) ? buyLogs : []).find(log => log.token_address === state.token_address) || {};
                        const latestPriceLog = (Array.isArray(priceLogs) ? priceLogs : []).find(log => log.token_address === state.token_address) || {};
                        const currentPrice = latestPriceLog.usd_price != null && !isNaN(parseFloat(latestPriceLog.usd_price)) ? parseFloat(latestPriceLog.usd_price) : (parseFloat(state.purchase_price) || 0);
                        const buyPrice = parseFloat(state.purchase_price) || 0;
                        const marketCap = parseFloat(latestPriceLog.marketcap) || parseFloat(state.buy_market_cap) || currentPrice * 1_000_000_000;
                        const profitPercent = buyPrice !== 0 && currentPrice !== 0 ? (((currentPrice - buyPrice) / buyPrice) * 100).toFixed(2) : '0';
                        return {
                            token_address: state.token_address,
                            token_name: state.token_name || tokenData.name,
                            buy_price_usd: buyPrice,
                            current_price_usd: currentPrice,
                            market_cap: marketCap,
                            profit: profitPercent,
                            buy_timestamp: buyLog.timestamp || null,
                            status: state.sold50 ? 'partial_sold' : 'open',
                            amount: parseFloat(state.amount) || 0,
                            icon: state.icon_url || tokenData.icon
                        };
                    } catch (error) {
                        console.error(`Error processing active trade for ${state.token_address || 'unknown'}:`, error);
                        return null;
                    }
                });
                activeTrades = (await Promise.all(activePromises)).filter(trade => trade !== null);

                dataCache.funbags.active = activeTrades;
                const activeTotal = tokenCount || dataCache.funbags.active.length;

                console.log('Fetching completed trades');
                const { data: sellLogsRaw, error: sellLogError, count: sellCount } = await withRetry(async () => await supabase
                    .from('bot_logs')
                    .select('token_address, amount, timestamp, event_type, sell_price', { count: 'exact' })
                    .in('event_type', ['sell_50', 'trailing_stop', 'stop_loss'])
                    .not('sell_price', 'is', null)
                    .order('timestamp', { ascending: false })
                );
                if (sellLogError) throw new Error(`Failed to fetch sell logs: ${sellLogError.message}`);
                console.log(`Completed trades count: ${sellCount}, data length: ${sellLogsRaw?.length}`);

                const sellLogs = (Array.isArray(sellLogsRaw) ? sellLogsRaw : []).filter(log => log.sell_price && !isNaN(parseFloat(log.sell_price)));
                const sellGroups = sellLogs.reduce((acc, sell) => {
                    if (!sell.token_address) return acc;
                    acc[sell.token_address] = acc[sell.token_address] || [];
                    acc[sell.token_address].push(sell);
                    return acc;
                }, {});

                let completedTrades = [];
                let totalProfitUsd = 0;
                const completedPromises = Object.entries(sellGroups).map(async ([tokenAddress, sells]) => {
                    try {
                        if (!tokenAddress) return null;
                        const tokenData = await fetchTokenData(tokenAddress);
                        const buyLog = (Array.isArray(buyLogs) ? buyLogs : []).find(log => log.token_address === tokenAddress);
                        if (!buyLog) return null;

                        const { data: buyState, error: buyStateError } = await supabase
                            .from('token_states')
                            .select('purchase_price, buy_market_cap, token_name, icon_url')
                            .eq('token_address', tokenAddress)
                            .single();
                        if (buyStateError) console.warn(`No token_state for ${tokenAddress}:`, buyStateError);

                        const buyPrice = buyState?.purchase_price ? parseFloat(buyState.purchase_price) : 0;
                        let totalAmount = 0;
                        let weightedSellPrice = 0;
                        sells.forEach(sell => {
                            const amount = parseFloat(sell.amount) || 0;
                            const sellPrice = parseFloat(sell.sell_price) || 0;
                            totalAmount += amount;
                            weightedSellPrice += amount * sellPrice;
                        });
                        const avgSellPrice = totalAmount !== 0 ? weightedSellPrice / totalAmount : 0;
                        const profitPercent = buyPrice !== 0 && avgSellPrice !== 0 ? (((avgSellPrice - buyPrice) / buyPrice) * 100).toFixed(2) : '0';
                        const profitUsd = totalAmount * (avgSellPrice - buyPrice);
                        totalProfitUsd += profitUsd;

                        return {
                            token_address: tokenAddress,
                            token_name: buyState?.token_name || tokenData.name,
                            buy_price_usd: buyPrice,
                            sell_price_usd: avgSellPrice,
                            profit: profitPercent,
                            total_profit_usd: profitUsd,
                            buy_timestamp: buyLog.timestamp || null,
                            sell_timestamp: sells[0].timestamp || null,
                            icon: buyState?.icon_url || tokenData.icon
                        };
                    } catch (error) {
                        console.error(`Error processing completed trade for ${tokenAddress}:`, error);
                        return null;
                    }
                });
                completedTrades = (await Promise.all(completedPromises)).filter(trade => trade !== null);

                dataCache.funbags.completed = completedTrades;
                const completedTotal = sellCount || dataCache.funbags.completed.length;

                totalProfitElement.textContent = `$${totalProfitUsd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

                // Render Active Trades
                let displayActiveTrades = [...dataCache.funbags.active];
                const activeSort = { ...sortStates.funbags.active };
                if (Object.keys(activeSort).length > 0) {
                    const column = Object.keys(activeSort)[0];
                    const direction = activeSort[column];
                    displayActiveTrades.sort((a, b) => {
                        let aValue = a[column];
                        let bValue = b[column];
                        if (['buy_price_usd', 'current_price_usd', 'market_cap', 'profit'].includes(column)) {
                            aValue = parseFloat(aValue) || 0;
                            bValue = parseFloat(bValue) || 0;
                        } else if (column === 'buy_timestamp') {
                            aValue = aValue ? new Date(aValue).getTime() : 0;
                            bValue = bValue ? new Date(bValue).getTime() : 0;
                        } else {
                            aValue = aValue ? aValue.toString().toLowerCase() : '';
                            bValue = bValue ? bValue.toString().toLowerCase() : '';
                        }
                        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                const activeStart = (activePage - 1) * pageSizes.funbags.active;
                const activeEnd = activeStart + pageSizes.funbags.active;
                displayActiveTrades = displayActiveTrades.slice(activeStart, activeEnd);

                activeTradesBody.innerHTML = '';
                activeTradesCards.innerHTML = '';
                if (displayActiveTrades.length === 0) {
                    activeStatus.textContent = 'No active trades found';
                    activeTradesCards.innerHTML = '<p>No active trades available.</p>';
                } else {
                    displayActiveTrades.forEach(trade => {
                        const tokenAddress = trade.token_address || '-';
                        const tokenName = trade.token_name || '-';
                        const buyPrice = trade.buy_price_usd || 0;
                        const currentPrice = trade.current_price_usd || 0;
                        const marketCap = trade.market_cap || 0;
                        const profit = trade.profit || '0';
                        const buyTime = trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-';
                        const iconUrl = trade.icon || 'https://via.placeholder.com/24?text=C';

                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="token-cell">
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </td>
                            <td>$${buyPrice.toFixed(8)}</td>
                            <td>$${currentPrice.toFixed(8)}</td>
                            <td>$${marketCap.toLocaleString()}</td>
                            <td class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</td>
                            <td>${buyTime}</td>
                        `;
                        activeTradesBody.appendChild(row);

                        const card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `
                            <p><span class="card-label">Token:</span> 
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </p>
                            <p><span class="card-label">Buy Price:</span> $${buyPrice.toFixed(8)}</p>
                            <p><span class="card-label">Current Price:</span> $${currentPrice.toFixed(8)}</p>
                            <p><span class="card-label">Market Cap:</span> $${marketCap.toLocaleString()}</p>
                            <p><span class="card-label">Profit:</span> <span class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</span></p>
                            <p><span class="card-label">Buy Time:</span> ${buyTime}</p>
                        `;
                        activeTradesCards.appendChild(card);
                    });
                    activeStatus.textContent = `Active trades loaded (${displayActiveTrades.length}/${activeTotal})`;
                }

                activeCurrentPage.textContent = activePage;
                activePrevPage.classList.toggle('disabled', activePage === 1);
                activeNextPage.classList.toggle('disabled', activeEnd >= dataCache.funbags.active.length);

                // Render Completed Trades
                let displayCompletedTrades = [...dataCache.funbags.completed];
                const completedSort = { ...sortStates.funbags.completed };
                if (Object.keys(completedSort).length > 0) {
                    const column = Object.keys(completedSort)[0];
                    const direction = completedSort[column];
                    displayCompletedTrades.sort((a, b) => {
                        let aValue = a[column];
                        let bValue = b[column];
                        if (['buy_price_usd', 'sell_price_usd', 'profit', 'total_profit_usd'].includes(column)) {
                            aValue = parseFloat(aValue) || 0;
                            bValue = parseFloat(bValue) || 0;
                        } else if (['buy_timestamp', 'sell_timestamp'].includes(column)) {
                            aValue = aValue ? new Date(aValue).getTime() : 0;
                            bValue = bValue ? new Date(bValue).getTime() : 0;
                        } else {
                            aValue = aValue ? aValue.toString().toLowerCase() : '';
                            bValue = bValue ? bValue.toString().toLowerCase() : '';
                        }
                        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                const completedStart = (completedPage - 1) * pageSizes.funbags.completed;
                const completedEnd = completedStart + pageSizes.funbags.completed;
                displayCompletedTrades = displayCompletedTrades.slice(completedStart, completedEnd);

                completedTradesBody.innerHTML = '';
                completedTradesCards.innerHTML = '';
                if (displayCompletedTrades.length === 0) {
                    completedStatus.textContent = 'No completed trades found';
                    completedTradesCards.innerHTML = '<p>No completed trades available.</p>';
                } else {
                    displayCompletedTrades.forEach(trade => {
                        const tokenAddress = trade.token_address || '-';
                        const tokenName = trade.token_name || '-';
                        const buyPrice = trade.buy_price_usd || 0;
                        const sellPrice = trade.sell_price_usd || 0;
                        const profit = trade.profit || '0';
                        const totalProfit = trade.total_profit_usd || 0;
                        const buyTime = trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-';
                        const sellTime = trade.sell_timestamp ? new Date(trade.sell_timestamp).toLocaleString() : '-';
                        const iconUrl = trade.icon || 'https://via.placeholder.com/24?text=C';

                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="token-cell">
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </td>
                            <td>$${buyPrice.toFixed(8)}</td>
                            <td>$${sellPrice.toFixed(8)}</td>
                            <td class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</td>
                            <td>$${totalProfit.toLocaleString()}</td>
                            <td>${buyTime}</td>
                            <td>${sellTime}</td>
                        `;
                        completedTradesBody.appendChild(row);

                        const card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `
                            <p><span class="card-label">Token:</span> 
                                <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                                <img src="${iconUrl}" alt="${tokenName} icon" class="token-icon" onload="this.classList.add('loaded')" onerror="this.src='https://via.placeholder.com/24?text=C';this.classList.add('loaded')">
                            </p>
                            <p><span class="card-label">Buy Price:</span> $${buyPrice.toFixed(8)}</p>
                            <p><span class="card-label">Sell Price:</span> $${sellPrice.toFixed(8)}</p>
                            <p><span class="card-label">Profit:</span> <span class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</span></p>
                            <p><span class="card-label">Total Profit:</span> $${totalProfit.toLocaleString()}</p>
                            <p><span class="card-label">Buy Time:</span> ${buyTime}</p>
                            <p><span class="card-label">Sell Time:</span> ${sellTime}</p>
                        `;
                        completedTradesCards.appendChild(card);
                    });
                    completedStatus.textContent = `Completed trades loaded (${displayCompletedTrades.length}/${completedTotal})`;
                }

                completedCurrentPage.textContent = completedPage;
                completedPrevPage.classList.toggle('disabled', completedPage === 1);
                completedNextPage.classList.toggle('disabled', completedEnd >= dataCache.funbags.completed.length);

                // Update sort indicators
                const activeHeaders = activeTable.querySelectorAll('th[data-sort]');
                activeHeaders.forEach(header => {
                    header.classList.remove('sort-asc', 'sort-desc');
                    const icon = header.querySelector('.sort-icon');
                    if (icon) icon.innerHTML = '↕';
                });
                if (Object.keys(activeSort).length > 0) {
                    const column = Object.keys(activeSort)[0];
                    const direction = activeSort[column];
                    const header = activeTable.querySelector(`th[data-sort="${column}"]`);
                    if (header) {
                        header.classList.add(`sort-${direction}`);
                        header.querySelector('.sort-icon').innerHTML = direction === 'asc' ? '↑' : '↓';
                    }
                }

                const completedHeaders = completedTable.querySelectorAll('th[data-sort]');
                completedHeaders.forEach(header => {
                    header.classList.remove('sort-asc', 'sort-desc');
                    const icon = header.querySelector('.sort-icon');
                    if (icon) icon.innerHTML = '↕';
                });
                if (Object.keys(completedSort).length > 0) {
                    const column = Object.keys(completedSort)[0];
                    const direction = completedSort[column];
                    const header = completedTable.querySelector(`th[data-sort="${column}"]`);
                    if (header) {
                        header.classList.add(`sort-${direction}`);
                        header.querySelector('.sort-icon').innerHTML = direction === 'asc' ? '↑' : '↓';
                    }
                }
            } catch (error) {
                console.error('Error in refreshTrades:', error);
                activeStatus.textContent = `Error loading active trades: ${error.message}`;
                completedStatus.textContent = `Error loading completed trades: ${error.message}`;
            } finally {
                activeStatus.classList.remove('loading');
                completedStatus.classList.remove('loading');
            }
        }

        // Event Listeners
        document.getElementById('funbags-monitoredRefreshBtn').addEventListener('click', debounce(() => refreshMonitoredCoins(1), 300));
        document.getElementById('funbags-topRefreshBtn').addEventListener('click', debounce(() => refreshTrades(1, 1), 300));
        document.getElementById('funbags-middleRefreshBtn').addEventListener('click', debounce(() => refreshTrades(1, 1), 300));
        document.getElementById('funbags-bottomRefreshBtn').addEventListener('click', debounce(() => refreshTrades(1, 1), 300));

        document.getElementById('funbags-monitoredPageSize').addEventListener('change', (e) => {
            pageSizes.funbags.monitored = parseInt(e.target.value);
            refreshMonitoredCoins(1);
        });
        document.getElementById('funbags-activePageSize').addEventListener('change', (e) => {
            pageSizes.funbags.active = parseInt(e.target.value);
            refreshTrades(1, pageStates.funbags.completed);
        });
        document.getElementById('funbags-completedPageSize').addEventListener('change', (e) => {
            pageSizes.funbags.completed = parseInt(e.target.value);
            refreshTrades(pageStates.funbags.active, 1);
        });

        document.getElementById('funbags-monitoredPrevPage').addEventListener('click', () => {
            if (pageStates.funbags.monitored > 1) {
                pageStates.funbags.monitored--;
                refreshMonitoredCoins(pageStates.funbags.monitored);
            }
        });
        document.getElementById('funbags-monitoredNextPage').addEventListener('click', () => {
            pageStates.funbags.monitored++;
            refreshMonitoredCoins(pageStates.funbags.monitored);
        });

        document.getElementById('funbags-activePrevPage').addEventListener('click', () => {
            if (pageStates.funbags.active > 1) {
                pageStates.funbags.active--;
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            }
        });
        document.getElementById('funbags-activeNextPage').addEventListener('click', () => {
            pageStates.funbags.active++;
            refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
        });

        document.getElementById('fun AscentButton(() => {
            if (pageStates.funbags.completed > 1) {
                pageStates.funbags.completed--;
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            }
        });
        document.getElementById('funbags-completedNextPage').addEventListener('click', () => {
            pageStates.funbags.completed++;
            refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
        });

        document.getElementById('funbags-monitoredBody').closest('table').addEventListener('click', (e) => {
            const header = e.target.closest('th[data-sort]');
            if (header) {
                const column = header.dataset.sort;
                const currentDirection = sortStates.funbags.monitored[column];
                sortStates.funbags.monitored = {};
                sortStates.funbags.monitored[column] = currentDirection === 'asc' ? 'desc' : 'asc';
                refreshMonitoredCoins(pageStates.funbags.monitored);
            }
        });

        document.getElementById('funbags-activeTradesBody').closest('table').addEventListener('click', (e) => {
            const header = e.target.closest('th[data-sort]');
            if (header) {
                const column = header.dataset.sort;
                const currentDirection = sortStates.funbags.active[column];
                sortStates.funbags.active = {};
                sortStates.funbags.active[column] = currentDirection === 'asc' ? 'desc' : 'asc';
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            }
        });

        document.getElementById('funbags-completedTradesBody').closest('table').addEventListener('click', (e) => {
            const header = e.target.closest('th[data-sort]');
            if (header) {
                const column = header.dataset.sort;
                const currentDirection = sortStates.funbags.completed[column];
                sortStates.funbags.completed = {};
                sortStates.funbags.completed[column] = currentDirection === 'asc' ? 'desc' : 'asc';
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            }
        });

        document.getElementById('funbags-monitoredFilter').addEventListener('input', (e) => {
            const filter = e.target.value.toLowerCase();
            const rows = document.getElementById('funbags-monitoredBody').querySelectorAll('tr');
            const cards = document.getElementById('funbags-monitoredCards').querySelectorAll('.card');
            rows.forEach(row => {
                const tokenName = row.querySelector('td:first-child a').textContent.toLowerCase();
                row.style.display = tokenName.includes(filter) ? '' : 'none';
            });
            cards.forEach(card => {
                const tokenName = card.querySelector('a').textContent.toLowerCase();
                card.style.display = tokenName.includes(filter) ? '' : 'none';
            });
        });

        document.getElementById('funbags-activeFilter').addEventListener('input', (e) => {
            const filter = e.target.value.toLowerCase();
            const rows = document.getElementById('funbags-activeTradesBody').querySelectorAll('tr');
            const cards = document.getElementById('funbags-activeTradesCards').querySelectorAll('.card');
            rows.forEach(row => {
                const tokenName = row.querySelector('td:first-child a').textContent.toLowerCase();
                row.style.display = tokenName.includes(filter) ? '' : 'none';
            });
            cards.forEach(card => {
                const tokenName = card.querySelector('a').textContent.toLowerCase();
                card.style.display = tokenName.includes(filter) ? '' : 'none';
            });
        });

        document.getElementById('funbags-completedFilter').addEventListener('input', (e) => {
            const filter = e.target.value.toLowerCase();
            const rows = document.getElementById('funbags-completedTradesBody').querySelectorAll('tr');
            const cards = document.getElementById('funbags-completedTradesCards').querySelectorAll('.card');
            rows.forEach(row => {
                const tokenName = row.querySelector('td:first-child a').textContent.toLowerCase();
                row.style.display = tokenName.includes(filter) ? '' : 'none';
            });
            cards.forEach(card => {
                const tokenName = card.querySelector('a').textContent.toLowerCase();
                card.style.display = tokenName.includes(filter) ? '' : 'none';
            });
        });

        document.getElementById('funbags-profitFilter').addEventListener('change', (e) => {
            const filter = e.target.value;
            const rows = document.getElementById('funbags-completedTradesBody').querySelectorAll('tr');
            const cards = document.getElementById('funbags-completedTradesCards').querySelectorAll('.card');
            rows.forEach(row => {
                const profitCell = row.querySelector('td:nth-child(4)');
                const profit = parseFloat(profitCell.textContent.replace('%', '')) || 0;
                if (filter === 'positive' && profit <= 0) {
                    row.style.display = 'none';
                } else if (filter === 'negative' && profit >= 0) {
                    row.style.display = 'none';
                } else {
                    row.style.display = '';
                }
            });
            cards.forEach(card => {
                const profitText = card.querySelector('.profit-positive, .profit-negative').textContent.replace('%', '');
                const profit = parseFloat(profitText) || 0;
                if (filter === 'positive' && profit <= 0) {
                    card.style.display = 'none';
                } else if (filter === 'negative' && profit >= 0) {
                    card.style.display = 'none';
                } else {
                    card.style.display = '';
                }
            });
        });

        document.getElementById('sexyModeToggle').addEventListener('click', () => {
            document.body.classList.toggle('sexy');
            const button = document.getElementById('sexyModeToggle');
            if (document.body.classList.contains('sexy')) {
                button.innerHTML = '<i class="fas fa-sun mr-2"></i> Normal Mode';
            } else {
                button.innerHTML = '<i class="fas fa-moon mr-2"></i> Sexy Mode';
            }
        });

        document.getElementById('funbags-exportBtn').addEventListener('click', () => {
            const csvRows = [];
            csvRows.push('Token,Buy Price (USD),Sell Price (USD),Profit (%),Total Profit (USD),Buy Time,Sell Time');
            dataCache.funbags.completed.forEach(trade => {
                const buyTime = trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-';
                const sellTime = trade.sell_timestamp ? new Date(trade.sell_timestamp).toLocaleString() : '-';
                csvRows.push(`"${trade.token_name || '-'}",${trade.buy_price_usd.toFixed(8)},${trade.sell_price_usd.toFixed(8)},${trade.profit},${trade.total_profit_usd.toFixed(2)},"${buyTime}","${sellTime}"`);
            });
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'completed_trades.csv');
            a.click();
            window.URL.revokeObjectURL(url);
        });

        // Initial load
        refreshMonitoredCoins(1);
        refreshTrades(1, 1);

        // One-time script to populate token_name and icon_url
        async function populateTokenMetadata() {
            console.log('Populating token metadata for existing tokens');
            const { data: tokens, error } = await supabase
                .from('token_states')
                .select('token_address')
                .or('token_name.is.null,icon_url.is.null');
            if (error) {
                console.error('Error fetching tokens for metadata population:', error);
                return;
            }
            console.log(`Found ${tokens.length} tokens needing metadata`);
            for (const token of tokens) {
                await fetchTokenData(token.token_address);
            }
            console.log('Metadata population complete');
        }
        // Uncomment to run once
        // populateTokenMetadata();
    });
</script>
