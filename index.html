<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Rich 1 Day</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="flex items-center justify-center min-h-screen">
    <div class="container mx-auto p-6 max-w-7xl">
        <div class="section-card">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl sm:text-4xl text-navy">Rich 1 Day</h1>
                <button id="sexyModeToggle" class="btn bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 flex items-center">
                    <i class="fas fa-moon mr-2"></i> Sexy Mode
                </button>
            </div>
            <div id="content-funbags" class="tab-content">
                <div class="mb-6 section-card">
                    <h2 class="text-xl text-navy mb-2">Summary</h2>
                    <p class="text-gray-700">Total Completed Profit: <span id="funbags-totalProfit" class="font-semibold text-navy">Calculating...</span></p>
                </div>
                <div class="mb-6 section-card">
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                        <h2 class="text-xl text-navy">Active Trades</h2>
                        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
                            <button id="funbags-topRefreshBtn" class="btn bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 flex items-center">
                                <i class="fas fa-sync-alt mr-2"></i> Refresh Trades
                            </button>
                            <button id="funbags-exportBtn" class="btn bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center">
                                <i class="fas fa-file-export mr-2"></i> Export Trades
                            </button>
                        </div>
                    </div>
                    <p id="funbags-active-status" class="text-gray-700 text-sm mb-2 status">Loading active trades...</p>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
                        <input type="text" id="funbags-activeFilter" class="filter-input" placeholder="Filter by Token...">
                        <select id="funbags-activePageSize" class="bg-light text-gray-700 px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500">
                            <option value="10">10 per page</option>
                            <option value="20">20 per page</option>
                            <option value="30">30 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                        </select>
                    </div>
                    <div class="table-container">
                        <table class="min-w-full">
                            <thead>
                                <tr>
                                    <th data-sort="token_name">Token<span class="sort-icon"></span></th>
                                    <th data-sort="buy_price_usd">Buy Price (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="current_price_usd">Current Price (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="market_cap">Market Cap (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="profit">Profit (%)<span class="sort-icon"></span></th>
                                    <th data-sort="buy_timestamp">Buy Time<span class="sort-icon"></span></th>
                                </tr>
                            </thead>
                            <tbody id="funbags-activeTradesBody"></tbody>
                        </table>
                    </div>
                    <div class="card-container">
                        <div id="funbags-activeTradesCards"></div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button id="funbags-middleRefreshBtn" class="btn bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 flex items-center">
                            <i class="fas fa-sync-alt mr-2"></i> Refresh Trades
                        </button>
                        <div class="flex items-center space-x-2">
                            <span id="funbags-activePrevPage" class="pagination-arrow disabled"><i class="fas fa-chevron-left"></i></span>
                            <span class="pagination-text text-gray-700">Page <span id="funbags-activeCurrentPage">1</span></span>
                            <span id="funbags-activeNextPage" class="pagination-arrow disabled"><i class="fas fa-chevron-right"></i></span>
                        </div>
                    </div>
                </div>
                <div class="mb-6 section-card">
                    <h2 class="text-xl text-navy mb-4">Completed Trades</h2>
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                        <p id="funbags-completed-status" class="text-gray-700 text-sm mb-2 sm:mb-0 status">Loading completed trades...</p>
                        <select id="funbags-profitFilter" class="bg-light text-gray-700 px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500">
                            <option value="all">All Trades</option>
                            <option value="positive">Positive Profit</option>
                            <option value="negative">Negative Profit</option>
                        </select>
                    </div>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
                        <input type="text" id="funbags-completedFilter" class="filter-input" placeholder="Filter by Token...">
                        <select id="funbags-completedPageSize" class="bg-light text-gray-700 px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500">
                            <option value="10">10 per page</option>
                            <option value="20">20 per page</option>
                            <option value="30">30 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                        </select>
                    </div>
                    <div id="funbags-completedTableContainer" class="table-container">
                        <table class="min-w-full">
                            <thead>
                                <tr>
                                    <th data-sort="token_name">Token<span class="sort-icon"></span></th>
                                    <th data-sort="buy_price_usd">Buy Price (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="sell_price_usd">Sell Price (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="profit">Profit (%)<span class="sort-icon"></span></th>
                                    <th data-sort="total_profit_usd">Total Profit (USD)<span class="sort-icon"></span></th>
                                    <th data-sort="buy_timestamp">Buy Time<span class="sort-icon"></span></th>
                                    <th data-sort="sell_timestamp">Sell Time<span class="sort-icon"></span></th>
                                </tr>
                            </thead>
                            <tbody id="funbags-completedTradesBody"></tbody>
                        </table>
                    </div>
                    <div class="card-container">
                        <div id="funbags-completedTradesCards"></div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <div class="flex items-center space-x-2">
                            <span id="funbags-completedPrevPage" class="pagination-arrow disabled"><i class="fas fa-chevron-left"></i></span>
                            <span class="pagination-text text-gray-700">Page <span id="funbags-completedCurrentPage">1</span></span>
                            <span id="funbags-completedNextPage" class="pagination-arrow disabled"><i class="fas fa-chevron-right"></i></span>
                        </div>
                        <button id="funbags-bottomRefreshBtn" class="btn bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 flex items-center">
                            <i class="fas fa-sync-alt mr-2"></i> Refresh Trades
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div id="error-message" class="hidden text-red-600 text-center mt-4">An error occurred while loading the dashboard. Please check the console for details.</div>
    </div>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Open+Sans:wght@400;600&display=swap');
        body {
            font-family: 'Open Sans', sans-serif;
            background-color: #f4f7fa;
            color: #2d3748;
            transition: background-color 0.3s, color 0.3s;
        }
        h1, h2 {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }
        select {
            font-family: 'Open Sans', sans-serif;
            font-size: 0.875rem;
        }
        .sexy {
            background-color: #1a0033;
            color: #f8d1e9;
        }
        .sexy .bg-light {
            background-color: #4b0082;
        }
        .sexy .text-gray-700 {
            color: #f8d1e9;
        }
        .sexy select {
            background-color: #4b0082;
            color: #f8d1e9;
            border-color: #ff69b4;
        }
        .sexy .bg-teal-600 {
            background: linear-gradient(145deg, #ff69b4, #c71585);
        }
        .sexy .hover\:bg-teal-700:hover {
            background: linear-gradient(145deg, #c71585, #ff69b4);
        }
        .sexy .profit-positive {
            color: #98fb98;
        }
        .sexy .profit-negative {
            color: #ff4040;
        }
        .sexy .card {
            background-color: #4b0082;
            border-color: #ff69b4;
        }
        .sexy .card:hover {
            background-color: #6a0dad;
            transform: translateY(-3px);
        }
        .sexy th {
            background-color: #2e004f;
        }
        .sexy tr:nth-child(even) {
            background-color: #4b0082;
        }
        .sexy tr:hover {
            background-color: #6a0dad;
            border-left: 3px solid #ff69b4;
        }
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .sexy .table-container {
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.5);
            border: 1px solid #ff69b4;
        }
        .loading::after {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #2c7a7b;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        .sexy .loading::after {
            border-color: #ff69b4;
            border-top-color: transparent;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            text-align: left;
            padding: 12px;
            border: 1px solid #e2e8f0;
        }
        .sexy th, .sexy td {
            border-color: #ff69b4;
        }
        th {
            background-color: #1e2a44;
            color: #ffffff;
            font-size: 0.85rem;
            white-space: nowrap;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
        }
        th:hover {
            background-color: #285e61;
        }
        .sexy th:hover {
            background-color: #6a0dad;
        }
        tr:nth-child(even) {
            background-color: #edf2f7;
        }
        tr:hover {
            background-color: #e6fffa;
            border-left: 3px solid #2c7a7b;
            transition: all 0.2s ease;
        }
        .pagination-arrow {
            cursor: pointer;
            padding: 8px;
            color: #2c7a7b;
            font-size: 1.5rem;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        .sexy .pagination-arrow {
            color: #ff69b4;
        }
        .pagination-arrow:hover:not(.disabled) {
            color: #285e61;
        }
        .sexy .pagination-arrow:hover:not(.disabled) {
            color: #c71585;
        }
        .pagination-arrow.disabled {
            color: #a0aec0;
            cursor: not-allowed;
        }
        a {
            color: #2c7a7b;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .sexy a {
            color: #ff69b4;
        }
        .profit-positive {
            color: #38a169;
            font-weight: 600;
        }
        .profit-negative {
            color: #e53e3e;
            font-weight: 600;
        }
        .card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            background-color: #ffffff;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }
        .card-label {
            font-weight: 600;
            color: #1e2a44;
            margin-right: 8px;
        }
        .sexy .card-label {
            color: #f8d1e9;
        }
        .btn {
            transition: transform 0.2s, background-color 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        .section-card {
            background: linear-gradient(145deg, #ffffff, #edf2f7);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .sexy .section-card {
            background: linear-gradient(145deg, #4b0082, #1a0033);
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.5);
        }
        .filter-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        .sexy .filter-input {
            background-color: #4b0082;
            color: #f8d1e9;
            border-color: #ff69b4;
        }
        .sort-icon::after {
            content: '';
            margin-left: 5px;
            font-size: 0.8rem;
        }
        .sort-asc::after {
            content: '↑';
        }
        .sort-desc::after {
            content: '↓';
        }
        .token-cell {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .token-cell a {
            flex-grow: 1;
        }
        .token-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-left: 8px;
            object-fit: cover;
        }
        .card-token {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .card-token a {
            flex-grow: 1;
        }
        @media (max-width: 640px) {
            .container {
                padding: 1rem;
            }
            h1 {
                font-size: 1.75rem;
            }
            .btn {
                padding: 10px 16px;
                font-size: 0.875rem;
                min-height: 48px;
                width: 100%;
            }
            .pagination-arrow {
                padding: 6px;
                font-size: 1.25rem;
            }
            .pagination-text {
                font-size: 0.875rem;
            }
            .status {
                font-size: 0.875rem;
                margin-top: 1.5rem;
            }
            .table-container {
                display: none;
            }
            .card-container {
                display: block;
            }
            .filter-input {
                font-size: 0.8rem;
            }
        }
        @media (min-width: 641px) {
            .card-container {
                display: none;
            }
        }
        @media (max-width: 400px) {
            .card {
                padding: 10px;
                font-size: 0.8rem;
            }
            .card-label, .card-value {
                font-size: 0.8rem;
            }
        }
        @media (max-width: 1024px) and (min-width: 641px) {
            th, td {
                padding: 10px;
                font-size: 0.875rem;
            }
            .btn {
                padding: 10px 20px;
                font-size: 0.875rem;
            }
            .filter-input {
                font-size: 0.85rem;
            }
        }
    </style>
    <script>
        console.log('Script loaded at', new Date().toISOString());

        // Initialize Supabase client with retry
        let supabase = null;
        async function initializeSupabase(retries = 3, delay = 1000) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    if (!window.supabase) {
                        console.warn(`Supabase library not loaded, attempt ${attempt}/${retries}`);
                        if (attempt === retries) throw new Error('Supabase library failed to load');
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    supabase = window.supabase.createClient(
                        'https://bprfbjsxbkitrbqszqpz.supabase.co',
                        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJwcmZianN4YmtpdHJicXN6cXB6Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NTg5NDMzOSwiZXhwIjoyMDYxNDcwMzM5fQ.wtFixniNTzbObmwjI1R8OuIusXB95w5waoXBN4DiiNw'
                    );
                    console.log('Supabase client initialized');
                    return true;
                } catch (error) {
                    console.error(`Supabase initialization attempt ${attempt} failed:`, error.message);
                    if (attempt === retries) {
                        alert('Failed to initialize Supabase. Please check your connection and credentials.');
                        document.getElementById('error-message').classList.remove('hidden');
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Moralis API configuration
        const MORALIS_API = 'https://solana-gateway.moralis.io';
        const MORALIS_API_KEY = 'YOUR_MORALIS_API_KEY_HERE'; // Replace with a valid key
        const MORALIS_CACHE_KEY = 'moralisTokenCache';
        let moralisTokenMap = new Map();

        // Load Moralis cache
        function loadMoralisCache() {
            try {
                const cached = localStorage.getItem(MORALIS_CACHE_KEY);
                return cached ? new Map(JSON.parse(cached)) : new Map();
            } catch (error) {
                console.error('Error loading Moralis cache:', error);
                return new Map();
            }
        }

        // Save Moralis cache
        function saveMoralisCache(cache) {
            try {
                localStorage.setItem(MORALIS_CACHE_KEY, JSON.stringify(Array.from(cache.entries())));
            } catch (error) {
                console.error('Error saving Moralis cache:', error);
            }
        }

        // Fetch Moralis token data
        async function fetchMoralisTokenData() {
            console.log('Fetching Moralis token data');
            try {
                const response = await fetch(`${MORALIS_API}/token/mainnet/exchange/pumpfun/bonding?limit=100`, {
                    headers: { 'Accept': 'application/json', 'X-API-Key': MORALIS_API_KEY }
                });
                if (!response.ok) throw new Error(`Moralis API error: ${response.status}`);
                const data = await response.json();
                console.log('Moralis data fetched:', data.result?.length || 0, 'tokens');

                const tokenMap = new Map();
                (data.result || []).forEach(token => {
                    if (token.tokenAddress) {
                        tokenMap.set(token.tokenAddress, {
                            name: token.name?.trim() || token.tokenAddress.slice(0, 8),
                            iconUrl: token.logo || ''
                        });
                    }
                });

                if (supabase) {
                    const tokensData = Array.from(tokenMap.entries()).map(([tokenAddress, tokenData]) => ({
                        token_address: tokenAddress,
                        token_name: tokenData.name,
                        icon_url: tokenData.iconUrl,
                        updated_at: new Date().toISOString()
                    }));

                    const { error } = await supabase
                        .from('token_states')
                        .upsert(tokensData, { onConflict: 'token_address' });
                    if (error) console.error('Error upserting Moralis data:', error.message, error.details);
                }

                moralisTokenMap = tokenMap;
                saveMoralisCache(tokenMap);
                return tokenMap;
            } catch (error) {
                console.error('Error fetching Moralis data:', error.message);
                return loadMoralisCache();
            }
        }

        // Sorting and Pagination States
        const sortStates = { funbags: { active: {}, completed: {} } };
        const pageStates = { funbags: { active: 1, completed: 1 } };
        const pageSizes = { funbags: { active: 10, completed: 10 } };
        const dataCache = { funbags: { active: [], completed: [] } };
        const tokenNameCache = new Map();

        // Retry mechanism
        async function withRetry(fn, retries = 3, delay = 1000) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    if (attempt === retries) throw error;
                    console.warn(`Attempt ${attempt} failed, retrying after ${delay}ms...`, error.message);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Fetch token data
        async function fetchTokenData(tokenAddress) {
            if (!tokenAddress) {
                console.warn('fetchTokenData: No token address provided');
                return { name: 'Unknown', iconUrl: '' };
            }
            if (tokenNameCache.has(tokenAddress)) return tokenNameCache.get(tokenAddress);

            if (moralisTokenMap.has(tokenAddress)) {
                const result = moralisTokenMap.get(tokenAddress);
                if (result.name && result.name !== tokenAddress.slice(0, 8)) {
                    tokenNameCache.set(tokenAddress, result);
                    return result;
                }
            }

            if (supabase) {
                try {
                    const { data, error } = await supabase
                        .from('token_states')
                        .select('token_name, icon_url')
                        .eq('token_address', tokenAddress)
                        .maybeSingle();
                    if (error) console.error('Supabase token error:', error.message, error.details);
                    if (data?.token_name && data.token_name !== tokenAddress.slice(0, 8)) {
                        const result = { name: data.token_name, iconUrl: data.icon_url || '' };
                        tokenNameCache.set(tokenAddress, result);
                        return result;
                    }
                } catch (error) {
                    console.error('Supabase token fetch error:', error.message);
                }
            }

            try {
                const response = await fetch(`${MORALIS_API}/token/mainnet/${tokenAddress}/metadata`, {
                    headers: { 'Accept': 'application/json', 'X-API-Key': MORALIS_API_KEY }
                });
                if (!response.ok) throw new Error(`Moralis metadata error: ${response.status}`);
                const token = await response.json();
                const result = { name: token.name?.trim() || tokenAddress.slice(0, 8), iconUrl: token.logo || '' };
                tokenNameCache.set(tokenAddress, result);
                moralisTokenMap.set(tokenAddress, result);
                saveMoralisCache(moralisTokenMap);

                if (supabase) {
                    const { error } = await supabase.from('token_states').upsert({
                        token_address: tokenAddress,
                        token_name: result.name,
                        icon_url: result.iconUrl,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'token_address' });
                    if (error) console.error('Error upserting token:', error.message, error.details);
                }

                return result;
            } catch (error) {
                console.warn('Token fetch failed for address:', tokenAddress, error.message);
                const fallback = { name: tokenAddress.slice(0, 8), iconUrl: '' };
                tokenNameCache.set(tokenAddress, fallback);
                return fallback;
            }
        }

        // Debounce function
        function debounce(func, wait = 300) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Refresh trades function
        async function refreshTrades(activePage = 1, completedPage = 1) {
            console.log('Refreshing trades, activePage:', activePage, 'completedPage:', completedPage);
            const prefix = 'funbags';
            const elements = {
                activeStatus: document.getElementById(`${prefix}-active-status`),
                completedStatus: document.getElementById(`${prefix}-completed-status`),
                activeBody: document.getElementById(`${prefix}-activeTradesBody`),
                activeCards: document.getElementById(`${prefix}-activeTradesCards`),
                completedBody: document.getElementById(`${prefix}-completedTradesBody`),
                completedCards: document.getElementById(`${prefix}-completedTradesCards`),
                totalProfit: document.getElementById(`${prefix}-totalProfit`),
                activePrev: document.getElementById(`${prefix}-activePrevPage`),
                activeNext: document.getElementById(`${prefix}-activeNextPage`),
                completedPrev: document.getElementById(`${prefix}-completedPrevPage`),
                completedNext: document.getElementById(`${prefix}-completedNextPage`),
                activeCurrent: document.getElementById(`${prefix}-activeCurrentPage`),
                completedCurrent: document.getElementById(`${prefix}-completedCurrentPage`)
            };
            const activeTable = elements.activeBody?.closest('table');
            const completedTable = elements.completedBody?.closest('table');

            if (!Object.values(elements).every(el => el) || !activeTable || !completedTable) {
                console.error('Missing trade DOM elements');
                if (elements.activeStatus) elements.activeStatus.textContent = 'Error: Missing DOM elements';
                if (elements.completedStatus) elements.completedStatus.textContent = 'Error: Missing DOM elements';
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            elements.activeStatus.textContent = 'Loading active trades...';
            elements.completedStatus.textContent = 'Loading completed trades...';
            elements.activeStatus.classList.add('loading');
            elements.completedStatus.classList.add('loading');
            elements.totalProfit.textContent = 'Calculating...';

            try {
                // Fetch Active Trades
                let activeTrades = [];
                let activeTotal = 0;
                if (supabase) {
                    try {
                        const { data: tokenStates, error: tokenError, count } = await withRetry(() => supabase
                            .from('token_states')
                            .select('token_address, purchase_price, highest_price, decimals, amount, updated_at, total_supply', { count: 'exact' })
                            .eq('bought', true)
                            .gt('amount', 0)
                        );
                        if (tokenError) throw new Error(`Active trades query error: ${tokenError.message}`);

                        console.log('Active trades fetched:', tokenStates?.length || 0, 'records');

                        activeTrades = await Promise.all((tokenStates || []).map(async state => {
                            if (!state.token_address) {
                                console.warn('Skipping active trade with missing token_address');
                                return null;
                            }
                            const tokenData = await fetchTokenData(state.token_address);
                            const buyPrice = parseFloat(state.purchase_price) || 0;
                            let currentPrice;
                            try {
                                const { data: priceLog } = await supabase
                                    .from('bot_logs')
                                    .select('usd_price')
                                    .eq('event_type', 'price_check')
                                    .eq('token_address', state.token_address)
                                    .order('timestamp', { ascending: false })
                                    .limit(1)
                                    .single();
                                currentPrice = priceLog?.usd_price ? parseFloat(priceLog.usd_price) : parseFloat(state.highest_price) || buyPrice;
                            } catch (error) {
                                console.warn('Error fetching price_check for token:', state.token_address, error.message);
                                currentPrice = parseFloat(state.highest_price) || buyPrice;
                            }
                            const profitPercent = buyPrice ? (((currentPrice - buyPrice) / buyPrice) * 100).toFixed(2) : '0';
                            const marketCap = currentPrice * (state.total_supply || 1_000_000_000);

                            let buyTimestamp = state.updated_at;
                            try {
                                const { data: buyLog } = await supabase
                                    .from('bot_logs')
                                    .select('timestamp')
                                    .eq('event_type', 'buy')
                                    .eq('token_address', state.token_address)
                                    .limit(1)
                                    .single();
                                if (buyLog?.timestamp) buyTimestamp = buyLog.timestamp;
                            } catch (error) {
                                console.warn('Error fetching buy timestamp for token:', state.token_address, error.message);
                            }

                            return {
                                token_address: state.token_address,
                                token_name: tokenData.name,
                                iconUrl: tokenData.iconUrl,
                                buy_price_usd: buyPrice,
                                current_price_usd: currentPrice,
                                market_cap: marketCap,
                                profit: profitPercent,
                                buy_timestamp: buyTimestamp
                            };
                        }));
                        activeTrades = activeTrades.filter(Boolean);
                        activeTotal = count || activeTrades.length;
                        dataCache.funbags.active = activeTrades;
                    } catch (error) {
                        console.error('Error fetching active trades:', error.message);
                        elements.activeStatus.textContent = `Failed to load active trades: ${error.message}`;
                    }
                } else {
                    elements.activeStatus.textContent = 'Supabase not initialized, cannot load active trades';
                }

                // Fetch Completed Trades
                let completedTrades = [];
                let completedTotal = 0;
                let totalProfitUsd = 0;
                if (supabase) {
                    try {
                        const { data: sellLogs, error: sellError, count } = await withRetry(() => supabase
                            .from('bot_logs')
                            .select('token_address, amount, timestamp, sell_price', { count: 'exact' })
                            .eq('event_type', 'trailing_stop')
                            .order('timestamp', { ascending: false })
                        );
                        if (sellError) throw new Error(`Completed trades query error: ${sellError.message}`);

                        console.log('Completed trades sell logs fetched:', sellLogs?.length || 0, 'records');

                        const sellGroups = (sellLogs || []).reduce((acc, sell) => {
                            if (!sell.token_address) return acc;
                            acc[sell.token_address] = acc[sell.token_address] || [];
                            acc[sell.token_address].push(sell);
                            return acc;
                        }, {});

                        completedTrades = await Promise.all(Object.entries(sellGroups).map(async ([tokenAddress, sells]) => {
                            if (!tokenAddress) {
                                console.warn('Skipping sell group with missing token_address');
                                return null;
                            }
                            const tokenData = await fetchTokenData(tokenAddress);

                            const { data: buyLog, error: buyError } = await supabase
                                .from('bot_logs')
                                .select('purchase_price, timestamp')
                                .eq('event_type', 'buy')
                                .eq('token_address', tokenAddress)
                                .lte('timestamp', sells[0].timestamp)
                                .order('timestamp', { ascending: false })
                                .limit(1)
                                .single();
                            if (buyError || !buyLog) {
                                console.warn('No buy log found for token:', tokenAddress, buyError?.message);
                                return null;
                            }

                            const buyPrice = parseFloat(buyLog.purchase_price) || 0;
                            if (!buyPrice) {
                                console.warn('Invalid buy price for token:', tokenAddress);
                                return null;
                            }

                            let totalAmount = 0, weightedSellPrice = 0;
                            for (const sell of sells) {
                                const sellPrice = parseFloat(sell.sell_price) || 0;
                                const amount = parseFloat(sell.amount) || 0;
                                if (amount > 0 && sellPrice > 0) {
                                    totalAmount += amount;
                                    weightedSellPrice += amount * sellPrice;
                                }
                            }

                            if (!totalAmount) {
                                console.warn('No valid sell amounts for token:', tokenAddress);
                                return null;
                            }

                            const avgSellPrice = weightedSellPrice / totalAmount;
                            const profitPercent = buyPrice ? (((avgSellPrice - buyPrice) / buyPrice) * 100).toFixed(2) : '0';
                            const profitUsd = totalAmount * (avgSellPrice - buyPrice);
                            totalProfitUsd += profitUsd;

                            return {
                                token_address: tokenAddress,
                                token_name: tokenData.name,
                                iconUrl: tokenData.iconUrl,
                                buy_price_usd: buyPrice,
                                sell_price_usd: avgSellPrice,
                                profit: profitPercent,
                                total_profit_usd: profitUsd,
                                buy_timestamp: buyLog.timestamp || null,
                                sell_timestamp: sells[0].timestamp || null
                            };
                        }));
                        completedTrades = completedTrades.filter(Boolean);
                        completedTotal = count || sellLogs.length;
                        dataCache.funbags.completed = completedTrades;
                    } catch (error) {
                        console.error('Error fetching completed trades:', error.message);
                        elements.completedStatus.textContent = `Failed to load completed trades: ${error.message}`;
                    }
                } else {
                    elements.completedStatus.textContent = 'Supabase not initialized, cannot load completed trades';
                }

                elements.totalProfit.textContent = `$${totalProfitUsd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

                // Display Active Trades
                let displayActiveTrades = [...activeTrades];
                const activeSort = sortStates.funbags.active;
                if (Object.keys(activeSort).length) {
                    const column = Object.keys(activeSort)[0];
                    const direction = activeSort[column];
                    displayActiveTrades.sort((a, b) => {
                        let aValue = a[column], bValue = b[column];
                        if (['buy_price_usd', 'current_price_usd', 'market_cap', 'profit'].includes(column)) {
                            aValue = parseFloat(aValue) || 0;
                            bValue = parseFloat(bValue) || 0;
                        } else if (column === 'buy_timestamp') {
                            aValue = aValue ? new Date(aValue).getTime() : 0;
                            bValue = bValue ? new Date(bValue).getTime() : 0;
                        } else {
                            aValue = aValue?.toLowerCase() || '';
                            bValue = bValue?.toLowerCase() || '';
                        }
                        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                const activeStart = (activePage - 1) * pageSizes.funbags.active;
                const activeEnd = activeStart + pageSizes.funbags.active;
                displayActiveTrades = displayActiveTrades.slice(activeStart, activeEnd);

                elements.activeBody.innerHTML = '';
                elements.activeCards.innerHTML = '';
                if (!displayActiveTrades.length && elements.activeStatus.textContent.includes('Loading')) {
                    elements.activeStatus.textContent = 'No active trades found';
                    elements.activeCards.innerHTML = '<p>No data available.</p>';
                } else if (displayActiveTrades.length) {
                    displayActiveTrades.forEach(trade => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="token-cell">
                                <a href="https://dexscreener.com/solana/${trade.token_address}" target="_blank" rel="noopener">${trade.token_name}</a>
                                ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${trade.token_name} icon" class="token-icon" />` : ''}
                            </td>
                            <td>$${trade.buy_price_usd.toFixed(8)}</td>
                            <td>$${trade.current_price_usd.toFixed(8)}</td>
                            <td>$${trade.market_cap.toLocaleString()}</td>
                            <td class="${parseFloat(trade.profit) >= 0 ? 'profit-positive' : 'profit-negative'}">${trade.profit}%</td>
                            <td>${trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-'}</td>
                        `;
                        elements.activeBody.appendChild(row);

                        const card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `
                            <p class="card-token">
                                <span class="card-label">Token:</span>
                                <a href="https://dexscreener.com/solana/${trade.token_address}" target="_blank" rel="noopener">${trade.token_name}</a>
                                ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${trade.token_name} icon" class="token-icon" />` : ''}
                            </p>
                            <p><span class="card-label">Buy Price:</span> $${trade.buy_price_usd.toFixed(8)}</p>
                            <p><span class="card-label">Current Price:</span> $${trade.current_price_usd.toFixed(8)}</p>
                            <p><span class="card-label">Market Cap:</span> $${trade.market_cap.toLocaleString()}</p>
                            <p><span class="card-label">Profit:</span> <span class="${parseFloat(trade.profit) >= 0 ? 'profit-positive' : 'profit-negative'}">${trade.profit}%</span></p>
                            <p><span class="card-label">Buy Time:</span> ${trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-'}</p>
                        `;
                        elements.activeCards.appendChild(card);
                    });
                    elements.activeStatus.textContent = `Loaded ${displayActiveTrades.length} of ${activeTotal} active trades`;
                }

                // Display Completed Trades
                let displayCompletedTrades = [...completedTrades];
                const completedSort = sortStates.funbags.completed;
                if (Object.keys(completedSort).length) {
                    const column = Object.keys(completedSort)[0];
                    const direction = completedSort[column];
                    displayCompletedTrades.sort((a, b) => {
                        let aValue = a[column], bValue = b[column];
                        if (['buy_price_usd', 'sell_price_usd', 'profit', 'total_profit_usd'].includes(column)) {
                            aValue = parseFloat(aValue) || 0;
                            bValue = parseFloat(bValue) || 0;
                        } else if (['buy_timestamp', 'sell_timestamp'].includes(column)) {
                            aValue = aValue ? new Date(aValue).getTime() : 0;
                            bValue = bValue ? new Date(bValue).getTime() : 0;
                        } else {
                            aValue = aValue?.toLowerCase() || '';
                            bValue = bValue?.toLowerCase() || '';
                        }
                        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                const completedStart = (completedPage - 1) * pageSizes.funbags.completed;
                const completedEnd = completedStart + pageSizes.funbags.completed;
                displayCompletedTrades = displayCompletedTrades.slice(completedStart, completedEnd);

                elements.completedBody.innerHTML = '';
                elements.completedCards.innerHTML = '';
                if (!displayCompletedTrades.length && elements.completedStatus.textContent.includes('Loading')) {
                    elements.completedStatus.textContent = 'No completed trades found';
                    elements.completedCards.innerHTML = '<p>No data available.</p>';
                } else if (displayCompletedTrades.length) {
                    displayCompletedTrades.forEach(trade => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="token-cell">
                                <a href="https://dexscreener.com/solana/${trade.token_address}" target="_blank" rel="noopener">${trade.token_name}</a>
                                ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${trade.token_name} icon" class="token-icon" />` : ''}
                            </td>
                            <td>$${trade.buy_price_usd.toFixed(8)}</td>
                            <td>$${trade.sell_price_usd.toFixed(8)}</td>
                            <td class="${parseFloat(trade.profit) >= 0 ? 'profit-positive' : 'profit-negative'}">${trade.profit}%</td>
                            <td>$${trade.total_profit_usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td>${trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-'}</td>
                            <td>${trade.sell_timestamp ? new Date(trade.sell_timestamp).toLocaleString() : '-'}</td>
                        `;
                        elements.completedBody.appendChild(row);

                        const card = document.createElement('div');
                        card.className = 'card';
                        card.innerHTML = `
                            <p class="card-token">
                                <span class="card-label">Token:</span>
                                <a href="https://dexscreener.com/solana/${trade.token_address}" target="_blank" rel="noopener">${trade.token_name}</a>
                                ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${trade.token_name} icon" class="token-icon" />` : ''}
                            </p>
                            <p><span class="card-label">Buy Price:</span> $${trade.buy_price_usd.toFixed(8)}</p>
                            <p><span class="card-label">Sell Price:</span> $${trade.sell_price_usd.toFixed(8)}</p>
                            <p><span class="card-label">Profit:</span> <span class="${parseFloat(trade.profit) >= 0 ? 'profit-positive' : 'profit-negative'}">${trade.profit}%</span></p>
                            <p><span class="card-label">Total Profit:</span> $${trade.total_profit_usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>
                            <p><span class="card-label">Buy Time:</span> ${trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-'}</p>
                            <p><span class="card-label">Sell Time:</span> ${trade.sell_timestamp ? new Date(trade.sell_timestamp).toLocaleString() : '-'}</p>
                        `;
                        elements.completedCards.appendChild(card);
                    });
                    elements.completedStatus.textContent = `Loaded ${displayCompletedTrades.length} of ${completedTotal} completed trades`;
                }

                // Update pagination
                elements.activeCurrent.textContent = activePage;
                elements.activePrev.classList.toggle('disabled', activePage === 1);
                elements.activeNext.classList.toggle('disabled', activeEnd >= activeTotal);

                elements.completedCurrent.textContent = completedPage;
                elements.completedPrev.classList.toggle('disabled', completedPage === 1);
                elements.completedNext.classList.toggle('disabled', completedEnd >= completedTotal);

                // Update sort indicators
                activeTable.querySelectorAll('th[data-sort]').forEach(header => {
                    header.classList.remove('sort-asc', 'sort-desc');
                    const icon = header.querySelector('.sort-icon');
                    if (icon) icon.innerHTML = '↕';
                });
                if (Object.keys(activeSort).length) {
                    const column = Object.keys(activeSort)[0];
                    const direction = activeSort[column];
                    const header = activeTable.querySelector(`th[data-sort="${column}"]`);
                    if (header) {
                        header.classList.add(`sort-${direction}`);
                        header.querySelector('.sort-icon').textContent = direction === 'asc' ? '↑' : '↓';
                    }
                }

                completedTable.querySelectorAll('th[data-sort]').forEach(header => {
                    header.classList.remove('sort-asc', 'sort-desc');
                    const icon = header.querySelector('.sort-icon');
                    if (icon) icon.innerHTML = '↕';
                });
                if (Object.keys(completedSort).length) {
                    const column = Object.keys(completedSort)[0];
                    const direction = completedSort[column];
                    const header = completedTable.querySelector(`th[data-sort="${column}"]`);
                    if (header) {
                        header.classList.add(`sort-${direction}`);
                        header.querySelector('.sort-icon').textContent = direction === 'asc' ? '↑' : '↓';
                    }
                }

                // Apply filters if present
                const activeFilter = document.getElementById('funbags-activeFilter').value.toLowerCase();
                if (activeFilter) {
                    elements.activeBody.querySelectorAll('tr').forEach(row => {
                        const tokenName = row.querySelector('td:first-child a')?.textContent.toLowerCase() || '';
                        row.style.display = tokenName.includes(activeFilter) ? '' : 'none';
                    });
                    elements.activeCards.querySelectorAll('.card').forEach(card => {
                        const tokenName = card.querySelector('a')?.textContent.toLowerCase() || '';
                        card.style.display = tokenName.includes(activeFilter) ? '' : 'none';
                    });
                }

                const completedFilter = document.getElementById('funbags-completedFilter').value.toLowerCase();
                const profitFilter = document.getElementById('funbags-profitFilter').value;
                if (completedFilter || profitFilter !== 'all') {
                    elements.completedBody.querySelectorAll('tr').forEach(row => {
                        const tokenName = row.querySelector('td:first-child a')?.textContent.toLowerCase() || '';
                        const profit = parseFloat(row.querySelector('td:nth-child(4)')?.textContent || '0');
                        const showToken = tokenName.includes(completedFilter);
                        const showProfit = profitFilter === 'all' ||
                            (profitFilter === 'positive' && profit > 0) ||
                            (profitFilter === 'negative' && profit < 0);
                        row.style.display = showToken && showProfit ? '' : 'none';
                    });
                    elements.completedCards.querySelectorAll('.card').forEach(card => {
                        const tokenName = card.querySelector('a')?.textContent.toLowerCase() || '';
                        const profitText = card.querySelector('.profit-positive, .profit-negative')?.textContent || '0%';
                        const profit = parseFloat(profitText);
                        const showToken = tokenName.includes(completedFilter);
                        const showProfit = profitFilter === 'all' ||
                            (profitFilter === 'positive' && profit > 0) ||
                            (profitFilter === 'negative' && profit < 0);
                        card.style.display = showToken && showProfit ? '' : 'none';
                    });
                }
            } catch (error) {
                console.error('Unexpected error in refreshTrades:', error.message);
                if (elements.activeStatus.textContent.includes('Loading')) {
                    elements.activeStatus.textContent = `Unexpected error: ${error.message}`;
                }
                if (elements.completedStatus.textContent.includes('Loading')) {
                    elements.completedStatus.textContent = `Unexpected error: ${error.message}`;
                }
                document.getElementById('error-message').classList.remove('hidden');
            } finally {
                elements.activeStatus.classList.remove('loading');
                elements.completedStatus.classList.remove('loading');
            }
        }

        // Attach event listeners
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded');
            const elements = {
                topRefresh: document.getElementById('funbags-topRefreshBtn'),
                middleRefresh: document.getElementById('funbags-middleRefreshBtn'),
                bottomRefresh: document.getElementById('funbags-bottomRefreshBtn'),
                activePageSize: document.getElementById('funbags-activePageSize'),
                completedPageSize: document.getElementById('funbags-completedPageSize'),
                activePrev: document.getElementById('funbags-activePrevPage'),
                activeNext: document.getElementById('funbags-activeNextPage'),
                completedPrev: document.getElementById('funbags-completedPrevPage'),
                completedNext: document.getElementById('funbags-completedNextPage'),
                activeFilter: document.getElementById('funbags-activeFilter'),
                completedFilter: document.getElementById('funbags-completedFilter'),
                profitFilter: document.getElementById('funbags-profitFilter'),
                sexyMode: document.getElementById('sexyModeToggle'),
                exportBtn: document.getElementById('funbags-exportBtn'),
                activeTable: document.getElementById('funbags-activeTradesBody'),
                completedTable: document.getElementById('funbags-completedTradesBody')
            };

            if (!Object.values(elements).every(el => el)) {
                console.error('Missing DOM elements:', Object.keys(elements).filter(key => !elements[key]));
                alert('Failed to initialize dashboard due to missing elements.');
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            elements.topRefresh.addEventListener('click', debounce(() => {
                console.log('Top refresh button clicked');
                refreshTrades(1, 1);
            }, 1000));
            elements.middleRefresh.addEventListener('click', debounce(() => {
                console.log('Middle refresh button clicked');
                refreshTrades(1, 1);
            }, 1000));
            elements.bottomRefresh.addEventListener('click', debounce(() => {
                console.log('Bottom refresh button clicked');
                refreshTrades(1, 1);
            }, 1000));

            elements.activePageSize.addEventListener('change', e => {
                console.log('Active page size changed to', e.target.value);
                pageSizes.funbags.active = parseInt(e.target.value);
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            });

            elements.completedPageSize.addEventListener('change', e => {
                console.log('Completed page size changed to', e.target.value);
                pageSizes.funbags.completed = parseInt(e.target.value);
                refreshTrades(pageStates.funbags.active, 1);
            });

            elements.activePrev.addEventListener('click', () => {
                if (pageStates.funbags.active > 1) {
                    console.log('Active prev page clicked');
                    pageStates.funbags.active--;
                    refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
                }
            });

            elements.activeNext.addEventListener('click', () => {
                console.log('Active next page clicked');
                pageStates.funbags.active++;
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            });

            elements.completedPrev.addEventListener('click', () => {
                if (pageStates.funbags.completed > 1) {
                    console.log('Completed prev page clicked');
                    pageStates.funbags.completed--;
                    refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
                }
            });

            elements.completedNext.addEventListener('click', () => {
                console.log('Completed next page clicked');
                pageStates.funbags.completed++;
                refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
            });

            elements.activeFilter.addEventListener('input', debounce(() => {
                console.log('Active filter input:', elements.activeFilter.value);
                const filter = elements.activeFilter.value.toLowerCase();
                elements.activeBody.querySelectorAll('tr').forEach(row => {
                    const tokenName = row.querySelector('td:first-child a')?.textContent.toLowerCase() || '';
                    row.style.display = tokenName.includes(filter) ? '' : 'none';
                });
                elements.activeTable.closest('.table-container').querySelectorAll('.card').forEach(card => {
                    const tokenName = card.querySelector('a')?.textContent.toLowerCase() || '';
                    card.style.display = tokenName.includes(filter) ? '' : 'none';
                });
            }, 300));

            elements.completedFilter.addEventListener('input', debounce(() => {
                console.log('Completed filter input:', elements.completedFilter.value);
                const filter = elements.completedFilter.value.toLowerCase();
                const profitFilter = elements.profitFilter.value;
                elements.completedTable.querySelectorAll('tr').forEach(row => {
                    const tokenName = row.querySelector('td:first-child a')?.textContent.toLowerCase() || '';
                    const profit = parseFloat(row.querySelector('td:nth-child(4)')?.textContent || '0');
                    const showToken = tokenName.includes(filter);
                    const showProfit = profitFilter === 'all' ||
                        (profitFilter === 'positive' && profit > 0) ||
                        (profitFilter === 'negative' && profit < 0);
                    row.style.display = showToken && showProfit ? '' : 'none';
                });
                elements.completedTable.closest('.table-container').querySelectorAll('.card').forEach(card => {
                    const tokenName = card.querySelector('a')?.textContent.toLowerCase() || '';
                    const profitText = card.querySelector('.profit-positive, .profit-negative')?.textContent || '0%';
                    const profit = parseFloat(profitText);
                    const showToken = tokenName.includes(filter);
                    const showProfit = profitFilter === 'all' ||
                        (profitFilter === 'positive' && profit > 0) ||
                        (profitFilter === 'negative' && profit < 0);
                    card.style.display = showToken && showProfit ? '' : 'none';
                });
            }, 300));

            elements.profitFilter.addEventListener('change', () => {
                console.log('Profit filter changed to', elements.profitFilter.value);
                const filter = elements.completedFilter.value.toLowerCase();
                const profitFilter = elements.profitFilter.value;
                elements.completedTable.querySelectorAll('tr').forEach(row => {
                    const tokenName = row.querySelector('td:first-child a')?.textContent.toLowerCase() || '';
                    const profit = parseFloat(row.querySelector('td:nth-child(4)')?.textContent || '0');
                    const showToken = tokenName.includes(filter);
                    const showProfit = profitFilter === 'all' ||
                        (profitFilter === 'positive' && profit > 0) ||
                        (profitFilter === 'negative' && profit < 0);
                    row.style.display = showToken && showProfit ? '' : 'none';
                });
                elements.completedTable.closest('.table-container').querySelectorAll('.card').forEach(card => {
                    const tokenName = card.querySelector('a')?.textContent.toLowerCase() || '';
                    const profitText = card.querySelector('.profit-positive, .profit-negative')?.textContent || '0%';
                    const profit = parseFloat(profitText);
                    const showToken = tokenName.includes(filter);
                    const showProfit = profitFilter === 'all' ||
                        (profitFilter === 'positive' && profit > 0) ||
                        (profitFilter === 'negative' && profit < 0);
                    card.style.display = showToken && showProfit ? '' : 'none';
                });
            });

            elements.sexyMode.addEventListener('click', () => {
                console.log('Sexy mode toggled');
                document.body.classList.toggle('sexy');
                elements.sexyMode.innerHTML = document.body.classList.contains('sexy') ?
                    '<i class="fas fa-sun mr-2"></i> Normal Mode' :
                    '<i class="fas fa-moon mr-2"></i> Sexy Mode';
            });

            elements.exportBtn.addEventListener('click', () => {
                console.log('Export button clicked');
                const csvRows = ['Token,Buy Price USD,Sell Price USD,Profit %,Total Profit USD,Buy Time,Sell Time'];
                dataCache.funbags.completed.forEach(trade => {
                    const buyTime = trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-';
                    const sellTime = trade.sell_timestamp ? new Date(trade.sell_timestamp).toLocaleString() : '-';
                    csvRows.push(`"${trade.token_name}",${trade.buy_price_usd.toFixed(8)},${trade.sell_price_usd.toFixed(8)},${trade.profit},${trade.total_profit_usd.toFixed(2)},"${buyTime}","${sellTime}"`);
                });
                const csvContent = csvRows.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'completed_trades.csv';
                a.click();
                window.URL.revokeObjectURL(url);
            });

            elements.activeTable.closest('table').addEventListener('click', e => {
                const header = e.target.closest('th[data-sort]');
                if (header) {
                    console.log('Active table sort clicked:', header.dataset.sort);
                    const column = header.dataset.sort;
                    const direction = sortStates.funbags.active[column];
                    sortStates.funbags.active = {};
                    sortStates.funbags.active[column] = direction === 'asc' ? 'desc' : 'asc';
                    refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
                }
            });

            elements.completedTable.closest('table').addEventListener('click', e => {
                const header = e.target.closest('th[data-sort]');
                if (header) {
                    console.log('Completed table sort clicked:', header.dataset.sort);
                    const column = header.dataset.sort;
                    const direction = sortStates.funbags.completed[column];
                    sortStates.funbags.completed = {};
                    sortStates.funbags.completed[column] = direction === 'asc' ? 'desc' : 'asc';
                    refreshTrades(pageStates.funbags.active, pageStates.funbags.completed);
                }
            });

            // Initial load
            (async () => {
                console.log('Starting initial load');
                const supabaseInitialized = await initializeSupabase();
                if (supabaseInitialized) {
                    await fetchMoralisTokenData();
                    await refreshTrades(1, 1);
                } else {
                    console.error('Skipping data load due to Supabase initialization failure');
                    document.getElementById('error-message').classList.remove('hidden');
                }
            })();
        });
    </script>
</body>
</html>
