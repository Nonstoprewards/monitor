async function refreshTrades(activePage = 1, completedPage = 1) {
    console.log(`Starting refreshTrades, activePage: ${activePage}, completedPage: ${completedPage}`);
    const prefix = 'funbags';
    const activeStatus = document.getElementById(`${prefix}-active-status`);
    const completedStatus = document.getElementById(`${prefix}-completed-status`);
    const activeTradesBody = document.getElementById(`${prefix}-activeTradesBody`);
    const activeTradesCards = document.getElementById(`${prefix}-activeTradesCards`);
    const completedTradesBody = document.getElementById(`${prefix}-completedTradesBody`);
    const completedTradesCards = document.getElementById(`${prefix}-completedTradesCards`);
    const totalProfitElement = document.getElementById(`${prefix}-totalProfit`);
    const activeTable = activeTradesBody?.closest('table');
    const completedTable = completedTradesBody?.closest('table');
    const activePrevPage = document.getElementById(`${prefix}-activePrevPage`);
    const activeNextPage = document.getElementById(`${prefix}-activeNextPage`);
    const completedPrevPage = document.getElementById(`${prefix}-completedPrevPage`);
    const completedNextPage = document.getElementById(`${prefix}-completedNextPage`);
    const activeCurrentPage = document.getElementById(`${prefix}-activeCurrentPage`);
    const completedCurrentPage = document.getElementById(`${prefix}-completedCurrentPage`);

    if (!activeStatus || !completedStatus || !activeTradesBody || !activeTradesCards || !completedTradesBody || !completedTradesCards || !totalProfitElement || !activeTable || !completedTable || !activePrevPage || !activeNextPage || !completedPrevPage || !completedNextPage || !activeCurrentPage || !completedCurrentPage) {
        console.error(`Missing DOM elements for funbags`);
        alert(`Failed to load Fun Bags dashboard. Check console for details.`);
        return;
    }

    activeStatus.textContent = 'Loading active trades...';
    completedStatus.textContent = 'Loading completed trades...';
    activeStatus.classList.add('loading');
    completedStatus.classList.add('loading');

    try {
        await refreshMonitoredCoins(pageStates.funbags.monitored);

        // Fetch active trades from token_states
        console.log('Fetching active trades from token_states');
        const { data: tokenStates, error: tokenError, count: tokenCount } = await withRetry(async () => await supabase
            .from('token_states')
            .select('token_address, purchase_price, amount, sold50, buy_market_cap', { count: 'exact' })
            .eq('bought', true)
            .gt('amount', 0)
        );
        if (tokenError) throw new Error(`Failed to fetch token states: ${tokenError.message}`);
        console.log(`Active trades count: ${tokenCount}, data length: ${tokenStates?.length}`);

        // Fetch buy logs for buy price and timestamp
        const { data: buyLogs, error: buyLogError } = await withRetry(async () => await supabase
            .from('bot_logs')
            .select('token_address, timestamp, usd_price, purchase_price, marketcap')
            .eq('event_type', 'buy')
        );
        if (buyLogError) throw new Error(`Failed to fetch buy logs: ${buyLogError.message}`);

        // Fetch latest price updates for current price and market cap
        const { data: priceLogs, error: priceError } = await withRetry(async () => await supabase
            .from('bot_logs')
            .select('token_address, usd_price, marketcap, timestamp')
            .eq('event_type', 'price_update')
            .order('timestamp', { ascending: false })
        );
        if (priceError) throw new Error(`Failed to fetch price logs: ${priceError.message}`);

        // Process active trades
        let activeTrades = [];
        const activePromises = (Array.isArray(tokenStates) ? tokenStates : []).map(async state => {
            try {
                if (!state.token_address) return null;
                const tokenData = await fetchTokenData(state.token_address);
                const buyLog = (Array.isArray(buyLogs) ? buyLogs : []).find(log => log.token_address === state.token_address) || {};
                
                // Find the latest price update for this token
                const latestPriceLog = (Array.isArray(priceLogs) ? priceLogs : [])
                    .filter(log => log.token_address === state.token_address)
                    .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())[0] || {};

                // Determine buy price
                const buyPrice = parseFloat(buyLog.purchase_price) || parseFloat(buyLog.usd_price) || parseFloat(state.purchase_price) || 0;
                if (buyPrice === 0) {
                    console.warn(`No valid buy price for ${state.token_address}`);
                    return null;
                }

                // Determine current price and market cap
                const currentPrice = parseFloat(latestPriceLog.usd_price) || buyPrice; // Fallback to buy price if no price update
                const marketCap = parseFloat(latestPriceLog.marketcap) || parseFloat(state.buy_market_cap) || (currentPrice * 1_000_000_000); // Fallback to buy market cap or estimate
                const profitPercent = buyPrice !== 0 && currentPrice !== 0 ? (((currentPrice - buyPrice) / buyPrice) * 100).toFixed(2) : '0';

                return {
                    token_address: state.token_address,
                    token_name: tokenData.name,
                    iconUrl: tokenData.iconUrl,
                    buy_price_usd: buyPrice,
                    current_price_usd: currentPrice,
                    market_cap: marketCap,
                    profit: profitPercent,
                    buy_timestamp: buyLog.timestamp || null,
                    status: state.sold50 ? 'partial_sold' : 'open',
                    amount: parseFloat(state.amount) || 0
                };
            } catch (error) {
                console.error(`Error processing active trade for ${state.token_address || 'unknown'}:`, error);
                return null;
            }
        });
        activeTrades = (await Promise.all(activePromises)).filter(trade => trade !== null);
        dataCache.funbags.active = activeTrades;
        const activeTotal = tokenCount || dataCache.funbags.active.length;

        // Fetch completed trades (unchanged, as itâ€™s not the focus)
        console.log('Fetching completed trades');
        const { data: sellLogsRaw, error: sellLogError, count: sellCount } = await withRetry(async () => await supabase
            .from('bot_logs')
            .select('token_address, amount, timestamp, event_type, sell_price, usd_price, marketcap', { count: 'exact' })
            .in('event_type', ['sell_50', 'trailing_stop', 'stop_loss'])
            .order('timestamp', { ascending: false })
        );
        if (sellLogError) throw new Error(`Failed to fetch sell logs: ${sellLogError.message}`);
        console.log(`Completed trades count: ${sellCount}, data length: ${sellLogsRaw?.length}`);

        const sellLogs = (Array.isArray(sellLogsRaw) ? sellLogsRaw : []).filter(log => (log.sell_price || log.usd_price || log.marketcap) && !isNaN(parseFloat(log.sell_price || log.usd_price || 0)));
        const sellGroups = sellLogs.reduce((acc, sell) => {
            if (!sell.token_address) return acc;
            acc[sell.token_address] = acc[sell.token_address] || [];
            acc[sell.token_address].push(sell);
            return acc;
        }, {});

        let completedTrades = [];
        let totalProfitUsd = 0;
        const completedPromises = Object.entries(sellGroups).map(async ([tokenAddress, sells]) => {
            try {
                if (!tokenAddress) return null;
                const tokenData = await fetchTokenData(tokenAddress);
                const buyLog = (Array.isArray(buyLogs) ? buyLogs : []).find(log => log.token_address === tokenAddress);
                if (!buyLog) return null;

                const { data: buyState, error: buyStateError } = await supabase
                    .from('token_states')
                    .select('purchase_price, amount, decimals, buy_market_cap, max_market_cap')
                    .eq('token_address', tokenAddress)
                    .single();
                if (buyStateError) return null;

                let buyPrice = parseFloat(buyState.purchase_price) || parseFloat(buyLog.purchase_price) || parseFloat(buyLog.usd_price) || 0;
                if (buyPrice === 0) return null;

                const totalSupply = 1_000_000_000;
                let totalAmount = 0;
                let weightedSellPrice = 0;
                let validSellEvents = 0;
                for (const sell of sells) {
                    let sellPrice = parseFloat(sell.sell_price) || parseFloat(sell.usd_price) || 0;
                    const amount = parseFloat(sell.amount) || 0;
                    const sellMarketCap = parseFloat(sell.marketcap) || 0;
                    const buyMarketCap = parseFloat(buyLog.marketcap) || parseFloat(buyState.buy_market_cap) || 0;

                    if (sellPrice === 0 || Math.abs(sellPrice - buyPrice) < 1e-8 || (sellMarketCap > 0 && Math.abs(sellMarketCap - buyMarketCap) < 100)) {
                        if (sell.event_type === 'sell_50') {
                            sellPrice = 9500 / totalSupply;
                        } else if (sell.event_type === 'trailing_stop') {
                            const maxMarketCap = parseFloat(buyState.max_market_cap) || 13262;
                            sellPrice = (maxMarketCap / totalSupply) * 0.95;
                        } else if (sell.event_type === 'stop_loss') {
                            sellPrice = 7600 / totalSupply;
                        }
                        const sellTimestamp = sell.timestamp ? new Date(sell.timestamp).getTime() : null;
                        if (sellTimestamp) {
                            const priceLog = (Array.isArray(priceLogs) ? priceLogs : []).find(log => 
                                log.token_address === tokenAddress && 
                                Math.abs(new Date(log.timestamp).getTime() - sellTimestamp) < 60000
                            );
                            sellPrice = priceLog && !isNaN(parseFloat(priceLog.usd_price)) ? parseFloat(priceLog.usd_price) : sellPrice;
                        }
                    }

                    if (amount > 0 && sellPrice > 0 && Math.abs(sellPrice - buyPrice) > 1e-8) {
                        totalAmount += amount;
                        weightedSellPrice += amount * sellPrice;
                        validSellEvents++;
                    }
                }

                if (totalAmount === 0 || weightedSellPrice === 0 || validSellEvents === 0) return null;

                const avgSellPrice = weightedSellPrice / totalAmount;
                const profitPercent = buyPrice !== 0 ? ((avgSellPrice - buyPrice) / buyPrice * 100).toFixed(2) : '0';
                const profitUsd = totalAmount * (avgSellPrice - buyPrice);
                totalProfitUsd += profitUsd;

                return {
                    token_address: tokenAddress,
                    token_name: tokenData.name,
                    iconUrl: tokenData.iconUrl,
                    buy_price_usd: buyPrice,
                    sell_price_usd: avgSellPrice,
                    profit: profitPercent,
                    total_profit_usd: profitUsd,
                    buy_timestamp: buyLog.timestamp || null,
                    sell_timestamp: sells[0].timestamp || null
                };
            } catch (error) {
                console.error(`Error processing completed trade for ${tokenAddress}:`, error);
                return null;
            }
        });
        completedTrades = (await Promise.all(completedPromises)).filter(trade => trade !== null);
        dataCache.funbags.completed = completedTrades;
        const completedTotal = sellCount || dataCache.funbags.completed.length;

        totalProfitElement.textContent = `$${totalProfitUsd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

        // Render Active Trades
        let displayActiveTrades = [...dataCache.funbags.active];
        const activeSort = { ...sortStates.funbags.active };
        if (Object.keys(activeSort).length > 0) {
            const column = Object.keys(activeSort)[0];
            const direction = activeSort[column];
            displayActiveTrades.sort((a, b) => {
                let aValue = a[column];
                let bValue = b[column];
                if (['buy_price_usd', 'current_price_usd', 'market_cap', 'profit'].includes(column)) {
                    aValue = parseFloat(aValue) || 0;
                    bValue = parseFloat(bValue) || 0;
                } else if (column === 'buy_timestamp') {
                    aValue = aValue ? new Date(aValue).getTime() : 0;
                    bValue = bValue ? new Date(bValue).getTime() : 0;
                } else {
                    aValue = aValue ? aValue.toString().toLowerCase() : '';
                    bValue = bValue ? bValue.toString().toLowerCase() : '';
                }
                const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                return direction === 'asc' ? comparison : -comparison;
            });
        }

        const activeStart = (activePage - 1) * pageSizes.funbags.active;
        const activeEnd = activeStart + pageSizes.funbags.active;
        displayActiveTrades = displayActiveTrades.slice(activeStart, activeEnd);

        activeTradesBody.innerHTML = '';
        activeTradesCards.innerHTML = '';
        if (displayActiveTrades.length === 0) {
            activeStatus.textContent = 'No active trades found';
            activeTradesCards.innerHTML = '<p>No active trades available.</p>';
        } else {
            displayActiveTrades.forEach(trade => {
                const tokenAddress = trade.token_address || '-';
                const tokenName = trade.token_name || '-';
                const buyPrice = trade.buy_price_usd || 0;
                const currentPrice = trade.current_price_usd || 0;
                const marketCap = trade.market_cap || 0;
                const profit = trade.profit || '0';
                const buyTime = trade.buy_timestamp ? new Date(trade.buy_timestamp).toLocaleString() : '-';

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="token-cell">
                        <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                        ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${tokenName} icon" class="token-icon">` : ''}
                    </td>
                    <td>$${buyPrice.toFixed(8)}</td>
                    <td>$${currentPrice.toFixed(8)}</td>
                    <td>$${marketCap.toLocaleString()}</td>
                    <td class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</td>
                    <td>${buyTime}</td>
                `;
                activeTradesBody.appendChild(row);

                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <p class="card-token">
                        <span class="card-label">Token:</span>
                        <a href="https://dexscreener.com/solana/${tokenAddress}" target="_blank" rel="noopener noreferrer">${tokenName}</a>
                        ${trade.iconUrl ? `<img src="${trade.iconUrl}" alt="${tokenName} icon" class="token-icon">` : ''}
                    </p>
                    <p><span class="card-label">Buy Price:</span> $${buyPrice.toFixed(8)}</p>
                    <p><span class="card-label">Current Price:</span> $${currentPrice.toFixed(8)}</p>
                    <p><span class="card-label">Market Cap:</span> $${marketCap.toLocaleString()}</p>
                    <p><span class="card-label">Profit:</span> <span class="${profit >= 0 ? 'profit-positive' : 'profit-negative'}">${profit}%</span></p>
                    <p><span class="card-label">Buy Time:</span> ${buyTime}</p>
                `;
                activeTradesCards.appendChild(card);
            });
            activeStatus.textContent = `Active trades loaded (${displayActiveTrades.length}/${activeTotal})`;
        }

        activeCurrentPage.textContent = activePage;
        activePrevPage.classList.toggle('disabled', activePage === 1);
        activeNextPage.classList.toggle('disabled', activeEnd >= dataCache.funbags.active.length);

        // Render Completed Trades (unchanged)
        completedCurrentPage.textContent = completedPage;
        completedPrevPage.classList.toggle('disabled', completedPage === 1);
        completedNextPage.classList.toggle('disabled', completedEnd >= dataCache.funbags.completed.length);

        // Update sort indicators
        const activeHeaders = activeTable.querySelectorAll('th[data-sort]');
        activeHeaders.forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
            const icon = header.querySelector('.sort-icon');
            if (icon) icon.innerHTML = 'â†•';
        });
        if (Object.keys(activeSort).length > 0) {
            const column = Object.keys(activeSort)[0];
            const direction = activeSort[column];
            const header = activeTable.querySelector(`th[data-sort="${column}"]`);
            if (header) {
                header.classList.add(`sort-${direction}`);
                header.querySelector('.sort-icon').innerHTML = direction === 'asc' ? 'â†‘' : 'â†“';
            }
        }

        const completedHeaders = completedTable.querySelectorAll('th[data-sort]');
        completedHeaders.forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
            const icon = header.querySelector('.sort-icon');
            if (icon) icon.innerHTML = 'â†•';
        });
        if (Object.keys(completedSort).length > 0) {
            const column = Object.keys(completedSort)[0];
            const direction = completedSort[column];
            const header = completedTable.querySelector(`th[data-sort="${column}"]`);
            if (header) {
                header.classList.add(`sort-${direction}`);
                header.querySelector('.sort-icon').innerHTML = direction === 'asc' ? 'â†‘' : 'â†“';
            }
        }
    } catch (error) {
        console.error('Error in refreshTrades:', error);
        activeStatus.textContent = `Error loading active trades: ${error.message}`;
        completedStatus.textContent = `Error loading completed trades: ${error.message}`;
    } finally {
        activeStatus.classList.remove('loading');
        completedStatus.classList.remove('loading');
    }
}
